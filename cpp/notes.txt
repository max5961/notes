-------------------------------------------------------------------------------
Structure of a Program
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/program_structure/
-------------------------------------------------------------------------------
    // this is a comment
    #include <iostream>

    int main() {
        std::cout << "Hello brah";

        return 0;
    }

Comments
    Two slash signs indicate that the rest of the line is a comment.  Comments
    have no effect on the behavior of the program
#include <iostream>
    Lines beginning with a hash sign (#) are "directives" that are read and
    interpreted by the "preprocessor".  They are special lines interpreted
    before compilation of the program.  In the case of #include <iostream>, this
    line instructs the preprocessor to include a section of standard c++ code,
    known as "header iostream", that allows the program to perform standard
    input and output operations, such as printing text to the screen as in the
    above example
Blank Line
    Blank lines have no effect on a program.  They simply improve readability of
    the code
int main()
    This function named "main" is a special function in all cpp programs.  It is
    the function called when the program is run.  The execution of every cpp
    program begins with the main function, regardless of where the function is
    actually located within the code.

    A function is a group of code statements that are given a name.  Function
    definitions are introduced with a succession of a type, a name, and a pair
    of parentheses which can optionally include parameters.
Open Curly Braces {}
    The open brace indicates the beginning of a function definition, and the
    closing brace indicates its end.  Everything between these braces is the
    function's body that defines what happens when the function is called.  All
    functions use braces to indicate the beginning and end of their definitions.
std::cout << "some text";
    This line is a cpp "statement".  A statement is an expression that can
    actually produce some effect.  It is the part of the program which specifies
    its actual behavior.  Statements are executed in the order that they appear
    within the functions body.

    The above statement has 3 parts (4 if you include the semicolon)

        std::cout
            Identifies the STandarD Character OUTput device (which is usually
            the computer screen)

        <<
            Indicates that what follows is inserted into std::cout

        "some text"
            The text within quotes is inserted into standard output

        ;
            All statements must end with a semicolon character.  One of the most
            common cpp syntax errors is forgetting to end a statement with a
            semicolon!

The structure of lines in cpp do not have strict rules.  For example:
    int main() {
        std::cout << "Hello World!";
    }

    // is the same thing as

    int main() { std::cout << "Hello World!"; }

    // is the same thing as

    int main() {
        std::cout <<
            "Hello World!";
    }

However, tools such as clang format can be used to format your code for you.
You will need a .clang-format file in your project directory


COMMENTS
-------------------------------------------------------------------------------
As noted above, comments do not affect the operation of the program, but they
provide an important tool to document directly within the source code what the
program does and how it operates.

Cpp supports two ways of commenting code
    // line comment
    /* block comment */

The line comment discards everything from where the pair of forward slashes are
found up to the end of that same line

The block comment can be a multiple line comment.  It discards everything
between the /* chars and the first appearance of the */ chars.


USING NAMESPACE STD
-------------------------------------------------------------------------------
This allows you to not need to prefix parts of the standard library with std::
For example, if you are are:
    using namespace std;
then you don't need to write "std::cout", you can simply write "cout"

All of the elements in the standard cpp library are declared within what is
called a namespace, which in the case of the standard library, the namespace is
std. To qualify elements of the std library, you must either prefix the element
with std:: or include the "using namespace std" statement in your code.

Note: The explicit qualification of the standard namespace by prefixing members
of the standard library with std:: is the only way to gaurantee name collisions
will never happen

Namespaces will be explained in more detail later in the notes


EXPRESSIONS VS STATEMENTS
-------------------------------------------------------------------------------
An expression is any segment of code that evaluates to a value.  Expressions can
consist of operators and operands.  Expressions produce a value, which can be
used as a part of a larger expression or a statement.

A statement is a complete line of code that ends with a ; which performs some
action.  A statement can be built with expressions.

Essentially, statements 'do' something whereas an expression 'evaluates' to
something.


-------------------------------------------------------------------------------
VARIABLES AND TYPES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/variables/
-------------------------------------------------------------------------------
We can define a variable as a portion of memory to store a value

Each variable needs a name that identifies and distinguishes it from the others


IDENTIFIERS
-------------------------------------------------------------------------------
An identifier is essentially another word for a variable name.

A "valid identifier" is a sequence of one or more letters, digits, or _ chars.

Spaces, punctuation marks, and symbols cannot be part of a valid identifier.

Identifiers must always begin with a letter.  They can also begin with a _, but
identifiers that begin with _ are in most cases reserved for compiler specific
keywords or externtal identifiers as well as identifiers containing two
successive underscore chars.

In no case can identifiers begin with a digit! (but they can include digits)

Identifiers cannot match keywords built into cpp.  Some of the standard reserved
keywords that cannot be used for programmer created identifiers can be viewed at
this link: https://cplusplus.com/doc/tutorial/variables/

Also note that cpp is a "case sensitive" language.  That means that an
identifier written in caps is not equivalent to another within the same name
written in lowercase.  RESULT is not the same as result


FUNDAMENTAL DATA TYPES
-------------------------------------------------------------------------------
The values of variables are stored somewhere in an unspecific location in memory
as zeros and ones.  The program does not need to know the exact location where a
variable is stored; it can simply refer to it by its identifier.

The program does however need to be aware of the type of data stored in the
variable.

It is not the same to store a simple integer as it is to store a char or a large
floating-point number. Even though a char and a large floating-point number are
both represented using zeros and ones, they are interpreted differently and do
not occupy the same amount of memory in most cases.

Fundamental data types are the basic types implemented directly by the language
that represent the basic storage units supported by most systems.

Fundamental data types classifications:
    - Character types:
        A single char such as 'A' or '$'.  The most basic type is char, which is
        a one byte (8 bits) character.  Other types are also provided for wider
        chars
    - Numerical integer types:
        Can store a whole number value such as 7 or 1024.  They exist in a
        variety of sizes, and can either be signed or unsigned, depending on
        whether they support negative values or not
    - Floating-point types:
        Represent real values such as 3.14 or 0.01, with different levels of
        precision.  The level of prevision depends on which of the 3 floating
        point types is used (float, double, long double).  Float is the least
        precise, double is more precise than float, and long double is more
        precise than double.
    - Boolean type:
        The boolean type, known in cpp as "bool", can only represent one of two
        states: true or false

Complete list of fundamental types in cpp:
    Character Types:
        char
            exactly 1 byte in size (at least 8 bits)
        char16_t
            at least 16 bits
        char32_t
            at least 32 bits
        wchar_t
            can represent the largest supported character set

    Integer Types (signed):
        signed char
            same as char.  At least 8 bits
        signed short int
            not smaller than char.  (at least 16 bits)
        signed int
            not smaller than short. (at least 16 bits)
        signed long int
            not smaller than int (at least 32 bits)
        signed long long int
            not smaller than long (at least 64 bits)

    Integer Types (unsigned):
        same as their signed counterparts

    Floating-point Types:
        float
            least precise
        double
            precision not less than float
        long double
            precision not less than double

    Boolean Type:
        bool

    Void Type
        void
            no storage

    Null pointer
        decltype(nullptr)

The names of certain integer types can be abbreviated without their signed and
int components.  For example, signed short int can be abbreviated as simply
short

Type sizes above are expressed in bits.  The more bits a type has, the more
distinct values it can represent, but this also means that it stores more
memory.

If the size or precision of a type is not a concern, then char, int, and double
are typically selected to represent characters, integers, and floating-point
values, respectively.  The other types in their rspective groups are only used
in particular cases.

The properties of fundamental types in a particular system and compiler
implementation can be obtained using the "numeric_limits" class.  (see standard
header <limits>). If for some reason, types of specific sizes are needed the
library defines certain fixed size type aliases in header <cstdint>

Cpp also supports a wide variety of types based on the fundamental types listed
above.  These other types are known as compound data types and are one of the
main strengths of the cpp language.


DECLARATION OF VARIABLES
-------------------------------------------------------------------------------
Cpp is a "strongly typed" language which means it requires every variable to be
declared with its type before its first use.  By doing this, it informs the
compiler the size to reserve in memory for the variable and how to interpret
it's value.

The syntax to declare a new variable in cpp is straightforward:
    int a, b, c;
    // the exact same meaning as
    int a;
    int b;
    int c;

    #include <iostream>
    int main() {

        // declaring variables
        int a, b;

        // process
        a = 20;
        b = 10;
        a++;
        int result = a - b;

        // print the result
        std::cout << result << "\n";

        return 0;
    }

In the above examples, the variables have an undetermined value until they are
assigned a value for the first time.  However, it is possible for the variable
to have a specific value from the moment it is declared. This is called in
initialization of a variable.

In cpp there are 3 ways to initialize vairables.  They are all equivalent and
are reminiscent of the evolution of the language over the years.

    c-like initialization (inherited from C):
        // type identifier = initialValue;
        int x = 0;
    constructor initialization (introduced by C++):
        // type identifier (initialValue);
        int x (0);
    uniform initialization:
        // type identifier {initialValue};
        int x {0}

    NOTE: spaces or no spaces between the initializers don't change anything


TYPE DEDUCTION: AUTO AND DECLTYPE
-------------------------------------------------------------------------------
When a new variable is initialized, the compiler can figure out what the type of
the variable is automatically by the initializer.  For this it suffices to use
auto as the type specifier for the variable.

    int foo = 0;
    auto bar = foo; // the same as: int bar = foo

    // same as

    int foo = 0;
    decltype(foo) bar = 0;

The above examples are not very practical and don't increase readability.
However, auto and decltype were introduced to improve code readability and for
when the type cannot be obtained by other means.


INTRODUCTION TO STRINGS
-------------------------------------------------------------------------------
The string class is an example of a compound type.  Variables of the string type
are able to store sequences of chars, to form words and/or sentences.

Unlike fundamental data types, the program needs to include the header where the
type is defined within the standard library.  For the string class, this is done
with the string header:

    #include <iostream>
    #include <string>

    int main() {
        std::string myString;
        myString = "this is my string brah";

        std::cout << myString << std::endl;

        return 0;
    }

Note: std::endl; ENDs the Line (printing a newline character and flushing the
stream).  It is considered best practice however to NOT use endl in most cases,
but to use '\n' instead as endl brings overhead into the program.

Note: You will still need to prefix string with std:: unless you are using the
standard namespace in your code.  You always need to include the string header
regardless.

As with fundamental data types, all initialization formats are also valid:

    std::string myString = "Hello World"; // c-like initialization
    std::string myString ("Hello World"); // constructor initialization
    std::string myString {"Hello World"}; // uniform initialization

Important note about the string header.  Some headers such as <iostream>
automatically include the <string> header within their header on most systems.
So your code might run fine despite not explicitly including the <string>
header and might lead you to believe you don't actually need it.  You DO need to
include it and even though it might run on most systems if its already included
in another header, it would be best practice to explicitly include the <string>
header if your program uses the string library.  Explicitly including headers in
your code can also aid in code readability.

The string class is a compound type. Compound types are used in the same way as
fundamental types.  The same syntax is used to declare variables and initialize
them.

For more details on standard cpp string, see the string class reference here:

    https://en.cppreference.com/w/cpp/string/basic_string


-------------------------------------------------------------------------------
CONSTANTS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/constants/
-------------------------------------------------------------------------------
Constants are expressions with a fixed value


LITERALS
-------------------------------------------------------------------------------
Literals are used to express particular values within the source code of a
program.

    int a = 5;

In the above example, the 5 was a "literal constant".

Literal constants can be classified into integer, floating-point, characters,
strings, Boolean, pointers, and user-defined literals

Integer Numerals:
    1776
    707

The above integer numerals are numerical constants that identify integer values.
1776 always represents the value: one thousand seven hundren seventy-six

In additon to decimal numbers, cpp allows the use of octal numbers (base 8) and
hexadecimal numbers (base 16) as literal constants.

    75   // decimal
    0113 // octal
    0x4b // hexadecimal

Integer literals are of type "int" by default.  However, certain suffixes maybe
appended to an integer literal to specify a different integer type:

    u or U   | unsigned
    --------------------
    l or L   | long
    --------------------
    ll or LL | long long

    75   // int
    75u  // unsigned int
    75l  // long
    75ul // unsigned long
    75lu // unsigned long

Floating Point Numerals:

    3.14159 // 3.14159
    6.02e23 // 6.02 x 10^23
    1.6e-19 // 1.6 x 10^-19
    3.0     // 3.0

The default type of floating point literals is "double".  Float point literals
of float or long double can be specified by adding one of the following
suffixes:

    f or F | float
    --------------------
    l or L | long double

    3.14159L  // long double
    6.02e23f  // float

Character and String Literals:
    'z'
    'p'
    "Hello world"
    "How do you do?"

    - enclosed in quotes
    - chars (single chars) are enclosed in single quotes ''
    - strings are enclosed in double quotes ""
    - string can be concatenated to form a string literal simply by separating
      them by one or more blank spaces, including tabs, newlines, or other valid
      blank characters

    std::string myString = "hello" " world";
    // the above is the same as
    std::string myString = "hello world";


    Character and string literals can also rerpresent special characters that
    are difficult or impossible otherwise express in the source code of a
    program.  These special characters are all preceded backslash character
    (escape).  Here is  alist of all the single character escape codes in cpp:
        \n: newline
        \r: carriage return
        \t: tab
        \v: vertical tab
        \b: backspace
        \f: form feed (page feed)
        \a: alert (beep)
        \': escaped single quote
        \": escaped double quote
        \?: escaped question mark
        \\: escaped backslash


TYPED CONSTANT EXPRESSIONS
-------------------------------------------------------------------------------
The "const" keyword gives the name of a variable a constant, or 'read only'
value:

    const double pi = 3.14159;
    const char newline = '\n';
    // remember, chars can only be initialized with single quotes


PREPROCESSOR DEFINITIONS (#DEFINE)
-------------------------------------------------------------------------------
Another mechanism to name constant values is the use of preprocessor definitions
using the define keyword:  It has the following form

    #define identifier replacement

    // EXAMPLE
    #define NEWLINE '\n'
    // note the lack of semicolon in the above
    // if a semicolon is included it is part of the replacement sequence and
    // included in all occurances

    // note that the type was not given in the #define.  That is because
    // #define just takes some text and tells the compiler, everytime you see this
    // identifier replace it with the replacement.  Its up to the programmer
    // to make sure its placed an an area that doesn't mess up the program.

    int main() {
        const double r = 5.0;
        const double circle = 2 * PI * r;
        cout << circle;
        cout << NEWLINE;
    }


OPERATORS
-------------------------------------------------------------------------------
Operators are used to operate on variables and constants

Assignment Operator =
    assigns a value to a variable
    int x = 5;

Arithmetic Operators
    + addition
    - subtraction
    * multiplication
    / division
    % modulo (remainder of a division of two values)

Compound Assignment Operators
    += plus equals
    -= minus equals
    *= times equals
    /= divide by equals
    %= modulo equals
    >>=
    <<=
    &=
    ^=
    |=

Increment and Decrement ++, --
    The increase operator and decrease operators increase or decrease the value
    stored in a variable by one.  The are nearly equivalent to +=1 and -=1

    They can be used as a prefix or a suffix.
        - When used as a prefix, the value is incremented/decremented, then it
          is assigned
        - When used as a suffix, the value is assigned, then it is incremented
          or decremented

        PREFIX (increment then assign)
        x = 3;
        y = ++x; // x contains 4, y contains 4 (x is incremented, then assigned)
        SUFFIX (assign then increment)
        x = 3;
        y = x++; // x contains 4, y contains 3 (x is assigned, then incremented)

Relational and Comparison Operators
    == equal to
    != not equal to
    < less than
    > greater than
    <= less than or equal to
    >= greater than or equal to

    (7 == 5) // evaluates to false
    (5 > 4)  // evalutes to true
    (3 != 2) // evaluates to true
    (6 >= 6) // evaluates to true
    (5 < 5)  // evaluates to false

    NOTE: You can actually assign a variable in a comparison.  Here is an
    example:

    const int a = 2;
    int b;
    if ((b = 2) == a) {
        std::cout << "This statement is true" << "\n";
    }

Logical Operators
    !
        NOT (only has one operand to its right and inverts its boolean value)
    &&
        AND (only yields true if both operands are true)
    ||
        OR (yields true if either one of the operands are true)

Conditional Ternary Operator (?)
    condition ? result1 : result2;

    The conditional operator evaluates an expression and returns one value if
    that expression evaluates to true, and a different one if the expression
    evaluates as false.

    int main() {
        const int a(2);
        const int b(4);
        const int c = a < b ? a : b;
        std::cout << c << "\n"; // c is assigned the value of a (2)
    }

Comma Operator (,)
    The comma operator is used to separate two or more expressions that are
    included where only one expression is expected.  When the set of expressions
    to be evaluated for a value, only the right most expression is considered.
    In the example below, this allows you  chain expressions together onto a
    single line to evaluate the value for variable a.

    int main() {
        // 1. assign value of 2 to b
        // 2. assign b + 4 to a
        int b;

        // only the right most expression is evaluated for the value of a
        int a = (b = 2, b + 4);
        std::cout << a << " " << b << "\n"; // 6 2

        return 0;
    }

Bitwise Operators
    & Bitwise AND
    | Bitwise inclusive OR
    ^ Bitwise exclusive OR
    ~ Unary complement (bit inversion)
    << Shift bits left (SHL)
    >> Shift bits right (SHR)

Explicit Type Casting Operator
    Type casting operators allow you to convert a value of a given type to
    another type.  This is completely different from decltype and auto, where
    the types are assigned based on another type.  With type casting you are
    converting a type to another type

    There are two ways to do this in cpp:

        1.
            float f = 3.14;
            int i = (int)f; // i contains 3
        2.
            float f = 3.14;
            int i = int(f);

sizeof
    This operator accepts one paramter, which can be either a variable or simply
    a type.  It returns the size in bytes of the type or variables

    // chars take up 1 byte in memory, so x is assigned a value of 1
    int x = sizeof(char)


Precedence of Operators
-------------------------------------------------------------------------------
A single expression may have multiple operators.  Certain operators have higher
precedence than others, but parts of expressions can be enclosed in parentheses
to override this precadence order.

When an expression has two operators with the same precedence level, grouping
determines which one is evaluated first.  Either left to right or right to left.

Enclosing all substatements in parenthese (even when unneccessary because of
their precadence) improves code readability.


-------------------------------------------------------------------------------
BASIC INPUT/OUTPUT
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/basic_io/
-------------------------------------------------------------------------------
The standard library provides many ways to interact with the user via it's input
and output features.

Cpp uses an abstraction called "streams" to perform input and output operations
in sequential media such as the screen, keyboard, or a file.

A stream is an entity where a program can either insert or extract chars to or
from.
    cin  | standard input stream
    cout | standard output stream
    cerr | standard error (output) stream
    clog | standard logging (output) stream


STANDARD OUTPUT
-------------------------------------------------------------------------------
On most program environments, the standard output by default is the screen, and
the cpp stream object defined to access it is "cout".  cout is part of the std
library, so it needs to be prefixed by std:: (or you need to make sure you are
using namespace std;)

For formatted output operations, cout is used with the insertion operator "<<"

    std::cout << "output sentence";
    std::cout << 120;
    std::cout << x;

Multiple insertion operations may be chained with a single statement:
    std::cout << "hello " << "world" << '\n';

In the above example, std::endl can be used in place of the newline character.
However, std::endl also has additional beavior.  std::endl also flushes the
stream buffer, which means that the output is requested to be physically written
to the device.  This effects mainly "fully buffered" streams, and while
std::cout is NOT a fully buffered stream it is still considered best practice to
use std;:endl ONLY when flushing the stream is desired.  A flushing operation
incurs an overhead and may produce a delay on some devices.


STANDARD INPUT
-------------------------------------------------------------------------------
On most program environments, the standard input is by default the keyboard, and
the cpp stream object designed to access it is the std::cin.

    int i;
    std::cout << "Please enter an integer value: ";
    std::cin >> i;
    std::cout << "The value you have entered is: " << i << "\n";

Note: The cin is inserted into the variable i in the above example with >>
instead of << because we are "inserting" the cin into i


STANDARD INPUT AND STRING
-------------------------------------------------------------------------------
std::cin extraction always considers spaces as terminating the value being
extracted.

In order to get an entire line from std::cin, use the std::getline function:

    getline(std::cin, string variable to assign to)

    // EXAMPLE
    #include <iostream>
    #include <string>

    int main() {
        std::cout << "What is your name?: ";
        std::string name;
        std::getline(std::cin, name);
        std::cout << "Haha it is nice to meet you, " << name << ".\n";

        return 0;
    }


STRINGSTREAM
-------------------------------------------------------------------------------
The standard header <sstream> defines a type called stringstream that allows a
string to be treated as a stream, and thus allows extraction or insertion
operations from/to the string in the same way as they are performed in std::cin
or std::cout.  For a better explanation, the comment in the example below do a
better job of explaining with stringstream does.

    #include <iostream>
    #include <sstream>
    #include <string>

    int main() {
        float price = 0;

        std::string userPrice;
        std::cout << "Enter da price: ";
        getline(std::cin, userPrice);
        std::stringstream(userPrice) >> price;
        /*
         if userPrice DOES contain a valid float, it will convert
         userPrice into a float and assign it to price

         if userPrice does NOT contain a valid float, price will
         remain unchanged
         */

        return 0;
    }


-------------------------------------------------------------------------------
STATEMENTS AND CONTROL FLOW
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/control/
-------------------------------------------------------------------------------
A cpp statement is an individual instruction in a program.  Statements always
end with a semicolon and are executed in the same order in which they appeaer in
the program.

A compound statement is a group of statements (each terminated by their own
semicolon), but grouped together in a block envlosed in curly braces.

    { statement1; statement2; statement3; }

The entire compound block is considered a single statement composed of multiple
sub statements.


SELECTION STATEMENTS: IF, ELSE IF, ELSE
-------------------------------------------------------------------------------
if (condition) statement

If a condition is met, and the statement to be ran is only a single statement,
you do not need to enclose the statement in curly braces.

    if (x == 100)
        std::cout << "x is 100";

If there is more than one statement to be ran after a condition is met, then you
DO need to envlose the statement in curly braces.

    if (x == 100) {
        std::cout << "x is 100" << "\n";
        std::cout << "nice brah" << "\n";
    }

IF, ELSE IF, ELSE

    if (x > 0) {
        std::cout << "x is positive" << "\n";
    } else if (x < 0) {
        std::cout << "x is negative" << "\n";
    } else {
        std::cout << "x is zero" << "\n";
    }
    // note: the curly braces is this example are not needed, because the
    // statements to be ran are all single statements, not compound
    // statements


ITERATION STATEMENTS (LOOPS)
-------------------------------------------------------------------------------
Loops repeat a statement a certain number of times, or while a condition is
fulfilled.  They are introduced by the keywords: "while", "do", and "for".


WHILE LOOPS
-------------------------------------------------------------------------------
while (expression) statement

        int i = 0;
        while (i <= 10) {
            if (i != 10) {
                std::cout << i << ", ";
            } else {
                std::cout << i;
            }
            ++n;
        }
        std::cout << "\n";


DO WHILE LOOPS
-------------------------------------------------------------------------------
do statment while (condition);

Do a statement at least once, then test for if the condition is met yet

    std::string myString;
    do {
        std::cout << "Enter some text: ";
        getline(cin, myString);
        std::cout << "You entered: " << myString << "\n";

        if (myString != "goodbye") {
            std::cout << "Btw, enter \"goodbye\" to exit" << "\n";
        } else {
            cout << "Goodbye brahh" << "\n";
        }

    } while (myString != "goodbye");

    // Example using bubble sort
    void bubbleSort(int arr[], int size) {
        bool isSorted;
        do {
            isSorted = true;
            for (int i = 0; i < size - 1; i++) {
                int left = arr[i];
                int right = arr[i + 1];

                if (left > right) {
                    arr[i + 1] = left;
                    arr[i] = right;
                    isSorted = false;
                }
            }
        } while (!isSorted);

        for (int i = 0; i < size; i++) {
            char lastChar;
            if (i == size - 1) {
                lastChar = '\n';
            } else {
                lastChar = ' ';
            }
            std::cout << arr[i] << lastChar;
        }
    }

    int main() {
        int arr[5]{5, 4, 3, 2, 1};

        bubbleSort(arr, 5);

        return 0;
    }


FOR LOOPS
-------------------------------------------------------------------------------
for (initialization; condition; increase;) statement;

1. initialization of the counter variable is executed
2. condition is checked.  If true, the loop continues, otherwise it ends and the
statement is skipped
3. statement or block is executed
4. increase or decrease is executed and the loop goes back to step 2
5. the loop ends

    for (int i = 0; i < 100; i++) {
        std::cout << i << "\n";
    }

The three fields in a for loop are actually optional, but in all cases the
semicolon signs between them are required.  A loop with no condition is
equivalent to a loop with true as a condition (endless loop)

It is also possible to handle a loop with multiple initializers, and increases
or decreases.

    // example
    // the i is increased while j is decreased
    int i, j;
    for (i = 0, j = 100; i != j; ++i, --j) {
        std::cout << i << " " << j << "\n";
    }
    // NOTE: you must declare i and j outside of the for loop, because you must
    cannot separate the two initializers by a semicolon.  If you separated them
    by a semicolon, then that would throw and error because a condition is
    expected after the first semicolon.


RANGE BASED FOR LOOP
-------------------------------------------------------------------------------
for (declaration : range ) statement;

The range based for loop iterates over all the elements in range.

"declaration" declares some variable able to take the value of an element in
this range.

Ranges are sequences of elements including arrays, containers, and any other
type supporting the functions begin and end.  String are a type of range for
example, because they are a sequence of chars.

This is like the "for of" loop in Javascript.

    std::string myString = "Hello world";
    for (char c : myString) {
        std::cout << "[" << c << "]";
    }
    // outputs [H][e][l][l][o][ ][w][o][r][l][d]

Range based for loops usually make use of the auto type deduction for the type
of elements with auto.  The example above can be rewritten with "auto" in place
of "char" for the declaration.


JUMP STATEMENTS
-------------------------------------------------------------------------------
break statement
    "break" leaves a loop even if the condition for its end is not fulfilled.
    It can be used to end an infinite loop, or force it to end before its
    natural end.

        for (int i = 10; i > 0; i--) {
            std::cout << i << ", ";

            if (i == 3) {
                std::cout << "countdown aborted we exiting early" << "\n";
                std::cout << "why are we exiting early?..." << "\n";
                std::cout << "I just felt like exiting early when i == 3"
                          << "\n";
                break;
            }
        }

continue statement
    The continue statement causes the program to skip the rest of the loop in
    the current iteration as if the end of the statement block had been reached,
    causing it to jump to the next iteration.

        for (int i = 0; i < 6; ++i) {
            if (i == 3)
                continue;
            cout << i << " ";
        }
        // Does not print 3.  Prints: 1 2 4 5

goto statement
    ALlows the programmer to make an absolute jump to anothe rpoint in the
    program.  This jump ignores nesting levels.

    This is a feature to use with care, and preferably within the same block of
    statements.

    The destination point is identified by a label, which is then used as an
    argument for the goto statement.  A label is made of a valid identifier,
    followed by a colon.

    Goto is considered a low-level feature, with no real uses cases in modern
    higher-level programming paradigms used with cpp.  Still, here is an
    example:

        int main() {
            int i = 10;

        myLabel:
            std::cout << i << ", ";
            --i;
            if (i > 0)
                goto myLabel;
            std::cout << "Lift off!!!!!!" << "\n";
        }


SELECTION STATEMENT: SWITCH / CASE STATEMENTS
-------------------------------------------------------------------------------
The purpose of a switch statement is to check for a value among a number of
possible constant expressions.  It is similar to stringing together if-else
statements.

    code>switch (expression) {
        case constant1:
            group-of-statements-1;
            break;
        case constant2:
            group-of-statements-2;
            break;
        default:
            default-group-of-statements;
    }
    /code>

    1. switch evaluates the expression
    2. expression is checked against constant1.  If it is not equal to
    constant2, then it is checked against constant 2 and so forth.  If it equal
    to any of the constants....
    3. It executes the group-of-statements until a break is found
    4. If none of the constants match the expression, the group-of-statements
    included after default: label are ran (if it exists).  The default is
    optional.

        const int num(5);
        switch (num) {
        case 1:
            std::cout << "x is 1 brah";
            break;
        case 5:
            std::cout << "x is 5 brah";
            break;
        default:
            std::cout << "x is not 1 or 5";
        }


-------------------------------------------------------------------------------
FUNCTIONS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/functions/
-------------------------------------------------------------------------------
A function is a group of statements that is given a name, and which can be
called from some point of the program.   Functions allow programs to structure
segments of code to perform individual tasks.

type name ( parameter1, parameter2, ...) { statements }

    "type"
        the type of the value returned by the function
    "name"
        is the identifier by which the function can be called
    "parameters (as many as needed)"
        each parameter consists of a type followed by an identifier, with each
        parameter being separated from the next by a comma.  Each parameter
        looks very much like a regular variable declaration and acts within the
        function as a regular variable which is local to the function.  The
        purpose of parameters is to allow arguments to be passed into the
        function when the function is called
    "statements"
        the functions body...a block of statements surrounded by curly brces
        that specify what the function actually does

            #include <iostream>
            using namespace std;

            #define newl '\n'

            int addition(int a, int b) {
                int r = a + b;
                return r;
            }

            int main() {
                cout << addition(5, 10) << newl;
                return 0;
            }

NOTE: you cannot define a function inside of a function

No matter the order in which they are defined, a cpp program always starts by
calling main().  Main is the only function called automatically.  The code in
any other function is only executed if it is called from main() directly or
indirectly.

    long fact(long n) {
        if (n <= 1) {
            return n;
        }
        return n * fact(n - 1);
    }

    int main() {
        std::cout << fact(5) << "\n";

        return 0;
    }


VOID FUNCTIONS: FUNCTIONS WITH NO TYPE
-------------------------------------------------------------------------------
If the function does not need a return value, the type to be used is void, which
is a special type to represent the absense of value.

Parentheses are REQUIRED to call the function as you would expect

If the execution of main ends normally without encountering a return statement,
the compiler assumes the function ends without an explicit return statement.
This only applies to main().  All other functions with a return type must end
with a proper return statement

When main returns zero, either implicitly or explicitly, it is interpreted by
the environment as that the program ended successfully.  Other values may be
returned by main, and some environments give access to that value to the caller
in some way, but this behavior is not required nor always portable between
platforms.  On all platforms, the values for main that are gauranteed to be
interpreted the same way are:

    0: program was successful
    EXIT_SUCCESS: The program was successful
    EXIT_FAILURE: The program failed

    NOTE - EXIT_SUCCESS AND EXIT_FAILURE are values defined in <cstlib>


PASSING BY VALUE AND PASSING BY REFERENCE
-------------------------------------------------------------------------------
In the case of this addition function for example:

    int addition(int a, int b) { return a + b; }
    int main() {
        int a = 5, b = 3, c;
        c = addition(5, 3);
        // c is 8, a and b are still 5 and 3 respectively
    }

The values of a and b are passed by value.  When calling the function, what is
passed to function as arguments are are copied into variables represented by the
function and those variables will have scope local to the function.

To pass by reference, prefix the param identifier by a &.  By passing by
reference, the value of the arguments passed into the function are also modified
if the function body contains statements that modify the values of the function
arguments.

This is not to be confused with the address of operator. When & is used in the
context of declaring function parameters (or declaring a type in the LHS of an
assignment), it signifies a type which is a reference. This creates an alias for
an existing object, which means that the function operates direclty on the
original variable passed to it, rather than a copy of the variable.  When
passing by reference, the & does NOT mean "address of", it simply means its a
reference or an alias to the parameter being passed when the function is called.
There is no need for the dereference operator (*) because the variables being
referenced are not pointers, they are simply references.

    // this will not modify the original value of a, only within the function
    // body will the local variable a which is a copy be modified
    int duplicate(int a) {
        a *= 2;
        return a;
    }

    int main() {
        int a = 5;
        duplicate(a);
        std::cout << a;

        return 0;
    }

    // this WILL modify the original value of a because a is now being passed
    // by reference
    int duplicate(int &a) {
        a *= 2;
        return a;
    }

    int main() {
        int a = 5;
        duplicate(a);
        std::cout << a;

        return 0;
    }


EFFICIENCY CONSIDERATIONS AND CONST REFERENCES
-------------------------------------------------------------------------------
Calling a function with parameters taken by value causes copies of the values to
be made.  This is a relatively inexpensive operation for fundamental types such
as int.  However, if the parameter is of a large compound type, it may result in
certain overhead.  For example, consider the following function.

    string concat(string a, string b) {
        return a + b;
    }

The function aboves takes two strings as parameters (by value), and returns the
result of the concatenating them.  By passing the arguments by value, the
function forces a and b to be copies of the arguments passed to the function
when it is called.  If these are long strings, it may mean copying large
quantities of data just for the function call.

This copy can be avoided all together if both parameters are made to be
"references"

    string concat(string &a, string &b) {
        return a + b;
    }

Arguments by reference do not require a copy.  The function operates directly on
(aliases of) the strings passed as arguments, and, at most, it might mean the
transfer of certain pointers to the function.  In this regard, the concat
function taking references is more efficient than the concat function taking
values, since it does not need to copy the expensive-to-copy string.

However, considering this, functions with reference parameters are sometimes
percieved as functions that MODIFY the arguments passed, because thats what
reference parameters are actually for.

The solution is for the function to gaurantee that its reference parameters are
NOT going to be modified by the function by qualifying the parameters as
constant.

    string concat(const string &a, const string &b) {
        return a + b;
    }

The above function now provides the efficiency of passing arguments as
references, but with the added safety of not being able to modify the values.
Again, this is helpful for compound data types, and for fundamental data
types this is not nearly as relevant.

*note on const references as function parameters:
    It is legal to assign a const reference to non const variable, but illegal
    to assign a non const reference to a const variable.  This is because
    assigning a non-const reference to a const variable drops the const
    qualifier.

        // okay
        int x = 10;
        const int &y = x;

        // throws error
        // const int x = 10;
        // int &y = x;

    This is why it is possible to create function parameters which are const
    references regardless of if the arguments themselves are const qualified.


INLINE FUNCTION CALLS
-------------------------------------------------------------------------------
    // example
    inline string catcat(const string &a, const string &b) {
        return a + b;
    }

The inline specifier informs the compiler that it is preferred to not run the
given function as a usual function call, but to expand the function "inline".

However, the compiler is also free to NOT inline it despite prefixing with the
"inline" specifier.

Most compilers are already optimized to generate inline functions when they see
an opportunity to improve efficiency, so defining a function as inline is not
usually necessary.


DEFAULT VALUES / ARGUMENTS IN PARAMETERS
-------------------------------------------------------------------------------
Functions can also have optional parameters, for which no arguments are required
in the call.
    int divide(int a, int b = 2) {
        int r;
        r = a / b;
        return r;
    }

    int main() {
        std::cout << divide(12) << '\n';    // 2
        std::cout << divide(20, 4) << '\n'; // 5
    }


DECLARING FUNCTIONS
-------------------------------------------------------------------------------
Functions cannot be called before they are declared.

However, function prototypes can be declared before they called, then defined
anywhere else in the code.

Function prototypes need to include the return type and the types of its
arguments, and use the same same syntax as used in the function definition.

Declaring functions prototypes before the function definition can be helpful to
reorganize the order of functions which can help with readability.  Also, in the
example below.... odd(int) calls even(int) and even(int) calls odd(int), so this
is an example where declaring a function before being defined is actually
necessary.

    #define newl '\n'

    void odd(int); // function prototype
    void even(int); // function prototype

    int main() {

        int x;
        do {
            std::cout << "Please enter a number (0 to exit brah): ";
            std::cin >> x;
            odd(x); // call odd which calls even inside of main()
        } while (x != 0);

        return 0;
    }

    void odd(int x) {
        if (x % 2 != 0) {
            std::cout << "It is odd brah" << newl;
        } else {
            even(x); // call even even though it is defined below
        }
    }

    void even(int x) {
        if (x % 2 == 0) {
            std::cout << "It is even brah!" << newl;
        } else {
            odd(x);
        }
    }

-------------------------------------------------------------------------------

    // here is another example of defining function prototypes before
    // they are used to possibly increase readability

    void helloWorld();
    void helloBrah();

    void helloBrah() {
        std::cout << "hello brah";
    }

    void helloWorld() {
        helloBrah();
    }

    int main() {
        helloBrah();

        return 0;
    }


RECURSIVITY
-------------------------------------------------------------------------------
Recursivity is the property that functions have to be called by themselves


-------------------------------------------------------------------------------
OVERLOADS AND TEMPLATES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/functions2/
-------------------------------------------------------------------------------
In cpp, two different functions can have the same name if:
    their parameters are different
        or
    their parameters are of a different type
        or
    they have a different number of parameters

This is called an "overloaded function"

A function cannot be overloaded based on its return type alone.  At least one
of its parameters must have a different type as well.

The reason for function overloads is to permit functions allowing different
types for params and return different types while still keeping similar
functionality.

The compiler will know which version of the function to call by examing the
types passed as arguments.

In the example below, the functions both perform different statements in the
function body.  While this is generally a bad idea, and creates confusion in the
example below, it is there to show it is possible.

    #include <iostream>

    int operate(int a, int b) {
        return a * b;
    }

    double operate(double a, double b) {
        return a / b;
    }

    int main() {
        int x = 5, y = 2;
        double n = 5.0, m = 2.0;

        std::cout << operate(x, y) << "\n";
        std::cout << operate(n, m) << "\n";

        return 0;
    }


FUNCTION TEMPLATES
-------------------------------------------------------------------------------
In the example given above with "overloaded functions", the functions did not
have the same definition, but they can and should in most cases have the same
definition.

Take the function sum as an example:

    int sum(int a, int b) { return a + b; }

It would be helpful if sum could take in and return more than just ints.  You
could overload sum with different return types and parameter types, but that is
a lot of repeating yourself.  For this problem, cpp gives you the ability to
define functions with "generic types", known as "function templates"

    template <class SomeType> SomeType subtraction(SomeType a, Sometype b) {
        return a - b;
    }

    template <typename SomeType> SomeType subtraction(SomeType a, SomeType b) {
        return a - b;
    }

It makes no difference if the generic typename is specified with "class" or
"typename".  However, typename is newer and more accurately describes its
purpose.

In the examples below, note that T is used as the template parameter name instead
of SomeType.  It makes no difference what the template parameter name is called,
but T is often used by convention.

    /*
       This example shows that the return type does NOT need to be the
       generic typename.  The return type can still be anything, or it CAN be
       the generic typename.

       The example below also shows that you do not need to explicitly call the
       function with the desired replacement for the generic type (in this case
       T).  The compiler will still be able to deduce the type automatically,
       but <type> explicitly tells the compiler what to set the type as
    */

    #include <iostream>

    template <typename T> T sum(T a, T b) {
        return a + b;
    }

    template <typename T> void printSum(T a, T b) {
        std::cout << (a + b) << '\n';
    }

    int main() {

        sum<int>(5, 15);
        sum<double>(7.232342, 15.9232);
        sum<float>(7.1, 3.4);

        printSum<int>(5, 15);
        printSum<double>(7.232342, 15.9232);
        printSum<float>(7.1, 3.4);

        printSum(5, 15);
        printSum(7.232342, 15.9232);
        printSum(7.1, 3.4);

        return 0;
    }

It is also possible to have multiple template parameters and it is also possible
for the function to still use regular non template types.

    // example
    template <typename T, typename U> bool isEqual(T a, U b) {
        return a == b;
    }

    int main() {
        // automatic template parameter deduction
        std::cout << isEqual(10, 10.5) << '\n';

        // explicitly pass in parameter types
        std::cout << isEqual<int, double>(10, 10.5) << '\n';
    }


NON TYPE TEMPLATE ARGUMENTS
-------------------------------------------------------------------------------
Template parameters can include not only types introduced by class or typename,
but ALSO can include expressions for a particular type.  The expression is
passed to the function body in the below example, but not used as an arg despite
the ability for the programmer to explicitly state the value of N.

While not just pass an extra argument?
    Passing an extra argument at runtime can achieve similar functionality, but
    it also introduces runtime overhead for passing and possible checking the
    argument.  In cases where the value does not change during program
    execution, the non type template arguments can lead to more efficient code
    that is easier for compilers to optimize.  For applications where
    readability is valued more than optimization, then passing an extra arg
    might be a better approach if it makes it more readable for the individual.

    // EXAMPLE
    #include <iostream>

    template <typename T, int N> T fixedMultiply(T val) {
        return val * N;
    }

    int main() {
        // Calls fixedMultiply with 50 as the argument to be multiplied.
        // The template parameters are specified explicitly:
        // - T is int, indicating the type of val.
        // - N is 2, a compile-time constant specifying the multiplier.
        // Since T is int and N is 2, the function multiplies 50 (val)
        // by 2 (N), and returns the result as an int.

        std::cout << fixedMultiply<int, 2>(50);

        return 0;
    }


-------------------------------------------------------------------------------
NAME VISIBILITY / NAMESPACES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/namespaces/
-------------------------------------------------------------------------------


SCOPES
-------------------------------------------------------------------------------
Named entities such as variables, functions, and compound types need to be
declared before being used in cpp.  The point in the program where this
declaration happens influences it's visibility.

An entity declared outside any block has "global scope", meaning that it's name
is valid anywhere in the code.

An entity declared within a block has "block scope".  Variables with block scope
are known as local variables.

The visibility of an entity with block scope extends until the end of the block,
which includes inner blocks.  (Yo Dawg I heard you liked scopes, so we put
infinite scopes within your scopes so you can have scope within your scope!)

An inner block, because it is a different block can however re-utilize a name
existing in an outer scope to refer to a different entity.

    int x = 10;
    int y = 20;
    {
        int x;  // inner scope x
        x = 20; // inner scope x is 20, outer scope x is 10 still
        y = 50; // outer scope y is 50, inner y wasn't defined again like x
        std::cout << "Inner Scope: x y" << '\n';
        std::cout << x << " " << y << '\n';
    }
    std::cout << "Outer Scope: x y" << '\n';
    std::cout << x << " " << y << '\n';


    // ANOTHER EXAMPLE

    int foo; // global variable

    void someFunction() {
        int bar; // local variable
        bar = 0;
    }

    void someOtherFunction() {
        foo = 1; // okay: foo is a global variable
        // bar = 2; // wrong: bar is not a global variable
        int bar = 2; // okay

    }


NAMESPACES
-------------------------------------------------------------------------------
Only one entity with a particular name can exist within a particular scope.
This is usually not a problem for local names since blocks tend to be relatively
short.  However, names can cause collisions more easily the further out you
bring the scope, which is where namespaces can help.

Namespaces allow you to group named entities that otherwise would have global
scope into more narrow scopes, which give them namespace scope.

    #include <iostream>

    // example creating two functions named value which have
    // different functionality
    namespace foo {
        int value() {
            return 5;
        }
    } // namespace foo

    namespace bar {
        const double pi = 3.1416;
        double value() {
            return 2 * pi;
        }
    } // namespace bar

    int main() {

        std::cout << foo::value() << '\n'; // outputs 5;
        std::cout << bar::value() << '\n'; // outputs 6.2832
        std::cout << bar::pi << '\n';      // outputs 3.1416

        return 0;
    }

The last part of the above example could also be rewritten in this way.  The
visibility of the namespaces encapsulated into blocks.

    {
        using namespace foo;
        std::cout << value() << '\n';
    }
    {
        using namespace bar;
        std::cout << value() << '\n';
        std::cout << pi << '\n';
    }

The keyword "using" introduces a name into the current declarative region, such
as a block, which aviods the need to qualify the name.

In the example below, the using keyword imports the specified variables into the
scope of the main function.  It imports x from namespace first, and y from
namespace second.  To access other variables within these namespaces, the fully
qualified name (e.g., namespace::variableName) may be used to explicitly specify
which variable is intended.  This is shown in the 3rd and 4th std::cout
statements in the main function.

    #include <iostream>
    #define NEWL "\n"

    namespace first {
        int x = 5;
        int y = 10;
    } // namespace first

    namespace second {
        double x = 3.1416;
        double y = 2.7183;
    } // namespace second

    int main() {

        using first::x;
        using second::y;

        std::cout << x << NEWL;         // output first::x   // 5
        std::cout << y << NEWL;         // output second::y  // 2.7183
        std::cout << first::y << NEWL;  // output first::y   // 10
        std::cout << second::x << NEWL; // output second::x  // 3.1416

        return 0;
    }

The using keyword can also be used as a directive to introduce an entire
namespace.  using and using namespace only have validity within the block they
are stated

    #include <iostream>
    #define NEWL "\n"

    namespace first {
        int x = 5;
        int y = 10;
    } // namespace first

    namespace second {
        double x = 3.1416;
        double y = 2.7183;
    } // namespace second

    int main() {

        using namespace first;
        std::cout << x << NEWL; // 5
        std::cout << y << NEWL; // 10

        return 0;
    }

Here is another example of using namespace, but this time showcasing behavior
within different scopes of code:

        // the below will throw an error IF namespace x and y both have the
        // variable someVariable
        {
            using namespace x;
            {
                using namespace y;
                std::cout << someVariable;
            }
        }

        // but this wont
        {
            using namespace x;
            std::cout << someVariable;
        }
        {
            using namespace y;
            std::cout << someVariable;
        }


NAMESPACE ALIASING
-------------------------------------------------------------------------------
Existing namespaces can be aliases with new names.  The syntax is as follows:
    namespace newName = currentName;


STORAGE CLASSES
-------------------------------------------------------------------------------

Static Storage:
    The storage for variables with global or namespace scope is allocated for
    the entire duration of the program.  This is called static storage.

Automatic Storage:
    The storage for local variables (those declared within a block) use
    automatic storage.  The storage for local variables is only available during
    the block in which they are declared; after that, the same storage may be
    used for a local variable of some other function, or otherwise used.

A substantial difference between variables with static and automatic storage:
    Variables with static storage, such as global variables that are not
    explicitly initialized are automatically initialized to zeros.

    Variables with automatic storage that are not explicitly initialized are
    left uninitialized and have an undetermined value.

    Here is an example to demonstate:

        #include <iostream>

        int x;

        int main() {
            // x is a global variable which has been uninitialized.
            // The output of the line below will be 0
            std::cout << x << '\n';

            // y is a local variable which has been uninitialized.
            // The output of the line below will be something like
            // 779647075, but could just about anything except for 0
            int y;
            std::cout << y << '\n';
            return 0;
        }


-------------------------------------------------------------------------------
ARRAYS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/arrays/
-------------------------------------------------------------------------------
An array is a series of elements of the same type placed in contiguous memory
locations that can be individually referenced by adding an index to its unique
identifier.  Contiguous means sharing  a common border, or next to each other in
sequence.

In arrays, each index is not necessarily 1 byte, or a single memory cell.  The
size of each index is determined by the type of element which the array stores.
For example, an array of 'int' in cpp typically occupies 4 bytes per element,
but this can vary based on the system.

A typical declaration for an array in cpp is:
    type name[numberOfElements];

type:
    a valid type (such as int, float...)
name:
    a valid identifier
numberOfElements:
    specifies the length of the array in terms of number of elements

int foo[5] // declare an array named foo that stores ints, and has a length of 5

By default, regular arrays of local scope (those declared within a function, for
example) are left uninitialized.  This means that none of its elements are set
to any particular value.  Their contents are undetermined at the point the array
is declared and will be determined when the function is run.

To pass an array in a function:

    void myFunction(int arr[]) {
        // statement(s)
    }

Here is an example of passing an array in a function but with a function
template.  This might make the code more readable by eliminating the need to
pass in a length argument to the function.

The below shows how this can be done with a non type template argument and with
simply passing the length of the array as a parameter.

    template <int L> void printArray(int arr[]) {
        for (int i = 0; i < L; i++) {
            std::cout << arr[i] << " ";
        }
    }

    void printWithoutTemplate(int arr[], int length) {
        for (int i = 0; i < length; i++) {
            std::cout << arr[i] << " ";
        }
    }

    int main() {
        int myArray[5] = {1, 2, 3, 4, 5};

        printArray<5>(myArray);

        printWithoutTemplate(myArray, 5);

        return 0;
    }


It is possible to leave the length of the array empty if there is an
initialization of values for an array.

    int foo[] = {5, 4, 3, 2, 1};

The above can also be written without the =

    int foo[] {5, 4, 3, 2, 1};

The values of elements in an array be accessed with the name[index] syntax

Indexes start with 0s


MULTIDIMENSIONAL ARRAYS
-------------------------------------------------------------------------------
To declare an array of length 3 with each cell in the array containing an
array of length 5, the syntax is:

    int h = 5, w = 3;
    int nestedArr[h][w];

    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            nestedArr[i][j] = j;
        }
    }

    for (int i = 0; i < h; i++) {
        std::cout << '\n';
        for (int j = 0; j < w; j++) {
            std::cout << myArr[i][j] << " ";
        }
    }


You could also explicitly initialize a nested array:

    int myArray[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    for (int i = 0; i < 3; i++) {
        std::cout << '\n';
        for (int j = 0; j < 3; j++) {
            std::cout << myArray[i][j] << " ";
        }
    }


ARRAYS AS PARAMETERS
-------------------------------------------------------------------------------
In cpp it is not possible to pass the entire block of memory represented by an
array to a function directly as an argument.  It is possible however, to pass
its address instead.  This is a much faster and more efficient operation
anyways.

To accept an array as a parameter for a function, the parameters can be declared
as the array type, but with empty brackets, omitting the actual size of the
array.

    void printArray(int arr[], int length) {
        for (int i = 0; i < length; i++) {
            std::cout << arr[i] << " ";
        }
        std::cout << newl;
    }

    int main() {
        int firstArray[]{5, 10, 15};
        int secondArray[]{2, 4, 6, 8, 10};

        printArray(firstArray, 3);  // 5 10 15
        printArray(secondArray, 5); // 2 4 6 8 10

        return 0;
    }

*** NEEDS FACT CHECKING ***
In the above example, when the functions are called, the arrays are not
necessarily passed by reference because the array identifier (which acts as a
pointer) will be copied despite the array itself not being copied.


LIBRARY ARRAYS
-------------------------------------------------------------------------------
The arrays above are directly implemented as a language feature which was
ineherited from the C language.  They however suffer some issues that can be
overcome with a defined header <array> which is a type template (class
template).  They are referred to as containers.

Containers are a library feature that operate in a similar way to built in
arrays, but they allow being copied (an expensive operation that copies the
entire block of memory) and decays pointers only when explicitly told to do so.

Here is an example of a container from the standard library in use:

    #include <iostream>
    #include <array>

    int main() {
        std::array<int, 3> myArray = {4, 5, 6};

        for (int i = 0; i < myArray.size(); i++) {
            // increment the value of the cell that myArray[i] holds
            ++myArray[i];
        }

        for (int elem : myArray) {
            std::cout << elem << ", ";
        }

        return 0;
    }

The above example can also be written with a normal array as well:

    #include <iostream>

    int main() {
        int myArray[3] = {4, 5, 6};

        for (int i = 0; i < 3; i++) {
            // increment the value of the cell that myArray[i] holds
            ++myArray[i];
        }

        for (int elem : myArray) {
            std::cout << elem << ", ";
        }

        return 0;
    }


IMPORTANT NOTE ON ASSIGNING VALUES TO ARRAYS:
-------------------------------------------------------------------------------
Arrays cannot be reassigned, but the individual cells of the array can be
reassigned with values of the array's type.

If you do not initialize an array with values upon declaration, then you would
need to assign each cell a value individually either by looping through each
cell in the array or by doing it manually.

The array name or identifier is a constant pointer to the place in memory it
holds elements. Logging the identifier without any indexes will log the address
in memory of the array, and in particular it points to the first index.

    int arr[5];

    // this will throw an error because an array is
    // not assignable after declaration
    arr = {1,2,3,4,5};

    // at this point, if you didn't initialize the
    // array with values, you would need to loop over
    // array and assign values individually

    std::cout << arr[4];


Here is an example using the dereference operator (*), which shows how the
arrays as pointers work.  More on arrays and pointers later on in the notes:

    int arr[5] = {1, 2, 3, 4, 5};

    std::cout << *arr << '\n'; // prints 1

    std::cout << *arr + 10 << '\n'; // prints 11

    std::cout << *(arr + 10) << '\n'; // unpredictable output

    std::cout << *(arr + 2) << '\n'; // prints 3

    // prints the memory address of arr.  This would be something like:
    // 0x7ff36be36c20
    std::cout << arr << '\n';


-------------------------------------------------------------------------------
CHARACTER SEQUENCES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/ntcs/
-------------------------------------------------------------------------------
Because strings are actually just sequences of characters, we can represent them
also as plain arrays of elements of a character type.

For example:

    char foo[20]; // an array that can store up to 20 elements of type char

By convention, the end of strings represented in character sequences is signaled
by a special character called the null character, whose literal value can be
written as \0 (backslash 0)

In the example above with foo; if we had stored the character sequences of
"Hello" and "Merry Christmas", the cells would look like this.  Notice the null
character at the end of each sequence of chars:

    [H][e][l][l][o][\0][][][][][][][]....[]
    [M][e][r][r][y][ ][C][h][r][i][s][t][m][a][s][\0][][][][]

Here is one way of initializing a null terminated character sequence:

    char myWord[] = {'H', 'e', 'l', 'l', 'o', '\0'};

Here is another way of doing the same as the above, but much easier:

    char myWord[] = "Hello";

The reason the above example works is because "Hello" is a string literal.  A
string literal IS simply an array of characters with a null terminated
character.  So a null terminated character sequence is also an array of chars
that are terminated with \0 and a string is simply a null terminated character
sequence or an array of chars terminated with a \0


STRINGS AND NULL TERMINATED CHARACTER SEQUENCES
-------------------------------------------------------------------------------
In the C language, plain arrays with null terminated sequences of chars are the
typical types to represent strings, which is why they are also known as
C-strings.

In cpp, even though the std lib defines a specific type for strings (class
string), plain arrays with null terminated sequences of chars (C-strings) are
still a natural way of representing strings in the language.

String literals still always produce null terminated character sequences, not
string objects.

In the std lib, both representations of string (C-strings and library strings)
coexist and most functions are overloaded to support both.

For example, std::cin and std::cout support null-terminated sequences directly.

However, a difference is that strigns have a dynamic size determined at runtime,
while the size of arrays is determined on compilation, before the program runs.

    #include <iostream>
    #include <string>

    int main() {
        char myNTCS[] = "Some text";

        std::string myString = myNTCS;

        // All of these print the same thing (Some text)
        std::cout << myString << '\n';
        std::cout << myString.c_str() << '\n';
        std::cout << myNTCS << '\n';
    }


-------------------------------------------------------------------------------
POINTERS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/pointers/
-------------------------------------------------------------------------------

INTRO TO POINTERS
-------------------------------------------------------------------------------
To this point, variables have been explained as locations in the computer's
memory, which can be accessed by their identifier (name).  This way, the program
does not need to care about the physical address of the data in memory; it
simply uses the identifier whenever it needs to refer to the variable

For a cpp program, the memory of a computer is like a succession of memory
cells.

Memory cells each have:
    one byte (8 bits)
    a unique address

These single-byte memory cells are ordered in a way that allows data larger than
a single byte to occupy memory cells that have consecutive addresses.  For
example, the memory cell with address 1776 follows immediately after memory cell
1775.

When a variable is declared the memory needed to store its value is assigned a
specific location in memory (its memory address).

Generally speaking, cpp programs do not actively decide the exact memory
addresses where variables reference the memory cells.  That task is left to the
environment where the program is run, generally the operating system decides on
the particular memory locations on runtime.

It still may be useful for a program to obtain the address of a variable during
runtime in order to access data cells that are at a certain position relative to
it.


ADDRESS OF OPERATOR (&)
-------------------------------------------------------------------------------
The address of a variable can be obtained by preceding a variable which has
already been declared with an ampersand (&), also known as the address-of
operator.

To get the value of a variable which which stores the address of another
variable (pointer), you need to use the dereference operator (*).  Here is an
example demonstrating the address of operator and the dereference operator:

    // foo is assigned a value of 25 at some memory address
    int foo = 25;

    // int *bar (makes bar an int pointer)
    // &foo (pass the memory address instead of the value)
    int *bar = &foo;

    // bar points to foo's memory address.  Printing bar will print the actual
    // memory address it is assigned to
    std::cout << bar << "\n";

    // prints a calculated address 5 int blocks ahead of foo's address
    // does not change bar
    std::cout << bar + 5 << "\n";

    // to print the value that bar references, you need to dereference bar with
    // the * operator to get the value that bar points too
    std::cout << *bar << "\n";

    // modify bar which will modify foo
    std::cout << ++*bar << "\n"; // prints 26

    std::cout << foo << "\n"; // prints 26

    // increment foo by 10
    // therefore increment the value that bar points to by 10
    *bar += 10;

    std::cout << foo << "\n";  // prints 36
    std::cout << *bar << "\n"; // prints 36

Note: while reading the above, the dereference operator is different than the *
used to define a pointer.  They are two separate things.  This will be discussed
in more detail later.


DEREFERENCE OPERATOR
-------------------------------------------------------------------------------
To access the value of the variable the pointer points to, use the dereference
operator by preceding the variable with the dereference operator.

    #define newl "\n"

    int foo = 25;    // foo is assigned a value of 25
    int *bar = &foo; // bar is a pointer to the memory address of foo
    int baz = *bar;  // baz is equal to the value that bar points to
    // baz is a copy of bar's value

    std::cout << "foo: " << foo << newl;  // prints foo: 25
    std::cout << "bar: " << *bar << newl; // prints bar: 25
    std::cout << "baz: " << baz << newl;  // prints baz: 25

    baz++;

    std::cout << "after incrementing baz: " << newl;
    std::cout << "foo: " << foo << newl;  // prints foo: 25
    std::cout << "bar: " << *bar << newl; // prints bar: 25
    std::cout << "baz: " << baz << newl;  // prints baz: 26

Note that the dereference operator is also used to modify the value of where a
pointer points to.  In the above example you could modify the value of foo with
the bar pointer by using the dereference operator and the pointer in the left
hand side (LHS) like this:

    *bar = 50;
    // now the address of foo would hold 50 instead of 25
    // since bar points to foo, the value of bar is also 50

When used on the RHS (right hand side), *bar translates to simply the value (of
whatever it points to), but on the LHS (left hand side), *bar means: the value
of where bar points to equals RHS


LHS / RHS / LVALUES / RVALUES / DIFFERENT PLACEMENTS OF * AND &
-------------------------------------------------------------------------------
Given that the * operator and the & operator behave differently in different
situations it is a good idea to clearly define how they behave differently in
these different situations.  First we will clearly define what these situations
are, and then we will clearly define the meaning of * and & in all of these
different situations.

DEFINITIONS:
    Locator Value (lvalue):
        Refers to an object that occupies some identifiable location in memory.
        lvalues can appear on both the LHS and RHS of an assignment

    Read Value (rvalue):
        Refers to data that does NOT have a stable / long term address but is
        still stored in memory temporarily.  Because rvalues are temporary, they
        cannot have values assigned to them, and thus they often appear on the
        RHS of an assignment so as to assign their value to some lvalue.  But
        you could also place an rvalue in a std::cout statement for example
        which wouldn't fall into the category of being RHS.  (You typically
        assign rvalues to lvalues, however, you also often assign lvalues to
        reference types)

        rvalues are:
            - literal constants
            - temporary objects created during the evaluation of an expression
              (3 + 4 - 2)
            - expressions / functions evaluating to non-lvalue results such as a
              function returning a non reference type

    Left Hand Side (LHS):
        The left side of an assignment statement where a value is assigned.  It
        typically needs to be a locator value (lvalue) because it is being
        assigned

    Right Hand Side (RHS):
        The right side of an assignment statement where the value being assigned
        is.  It can be either an lvalue or an rvalue depending on the context.

    Parameters vs Arguments:
        For the context of the explanations below its important to clarify the
        distinction between parameters and arguments as they are often used
        interchangeably which is incorrect.

        Parameters are variables declared in a function parameter list when the
        function is DECLARED.  They will be assigned to the arguments passed
        into the function when the function is called.

        Arguments are variables that are passed into the function when the
        function is CALLED.

        PARAMETERS are to DECLARING A FUNCTION as ARGUMENTS are to CALLING A
        FUNCTION


* BEHAVIOR;
    The * operator is used with pointers to either define them or to
    'dereference' them.  You can think of the * always being left of its
    identifier and although this is accurate syntactically, it is inaccurate
    from a conceptual point of view.

    When defining a type, the * operator goes on the right of the type, and when
    dereferencing it goes on the left of the identifier.

    'int *' is a type which means 'int pointer'
    '*somePointer' means the value of where somePointer points to

    POINTER DEFINITIONS

        int *ptr;

        The above declares a pointer which can only point to integers.  When
        used in a definition, * denotes a that the type of the variable is a
        pointer.  The above example has the type: 'int *' (int pointer)

    DEREFERENCE OPERATOR:
        - When used in an expression, * is the dereference operator which means
          it accesses the value of where the pointer points to in memory.

        - LHS DEREFERENCE OPERATOR:

            // the address 'ptr' points to is assigned the value of int 5
            *ptr = 5;

            The above assigns the RHS value (5) to the location in memory which
            'ptr' points to.  In this case the RHS value is an 'rvalue' because
            it is a literal constant assigned to a temporary memory location

        - RHS DEREFERENCE OPERATOR:

            // int x is equal to the value held by the memory address which
            // 'ptr' points to
            int x = *ptr;

            The above initializes the variable 'x' with the value held by the
            memory location which 'ptr' points to

    IN FUNCTION PARAMETERS:
        - When a function PARAMETER includes a POINTER, it expects an address to
          be passed in its place as an ARGUMENT when the function is called.
          This address can either be in the form of a pointer of the same type
          which has already been initialized, OR a non pointer variable which
          has been qualified with the address-of operator (&).  When passing a
          pointer in a function, the * tells the function that the parameter is
          of type 'someType *' or in other words 'pointer to someType'.  The *
          in this case is not the dereference operator.  It is more closely
          aligned with how * is used in pointer initialization.

              void modify(int *p) {*p = 50;}
              int main() { int x = 10; modify(&x); return 0;}


POINTERS WITHOUT * BEHAVIOR:
    Pointers without the * operator prefixing the identifier yields the address
    the pointer points to.  For simplicity purposes, in the examples below,
    assume the pointers have already been declared.

    ASSIGNING A POINTER TO A NEW LOCATION:

        // the address 'ptr' points to is equal to the address of 'x'
        ptr = &x

        The address ptr points to is assigned to the 'address of' the x
        variable.

    ALLOCATING / DEALLOCATING MEMORY WITH A POINTER:

        // allocate memory which is now controlled by 'ptr'
        ptr = new int(10);

        In the above snippet, 'ptr' dynamically allocates a memory block the size
        of an int to the heap. 'ptr' now points to and can control the memory
        block created by the new keyword.

        // deallocate the memory which 'ptr' points to.
        delete ptr;

        In the above snippet, 'ptr' frees the memory block it points to on the
        heap, but does not delete the pointer itself.  'ptr' still points to the
        same block of memory

    IN FUNCTION ARGUMENTS:
        When a function is defined with a pointer as a parameter, it expects the
        corresponding argument to be an address, so it can be one of the
        following:

            a existing pointer which already points at something

                                    OR

            a variable qualified with & so that the pointer has an address to
            point to


& BEHAVIOR
    AS ADDRESS-OF OPERATOR:
        - When used in an expression, & means the 'address of its operand'.

        - RHS ADDRESS-OF OPERATOR:

            // Assigns the address of 'x' to the pointer 'ptr'
            int *ptr = &x;

            // same as
            int *ptr;
            ptr = &x;

            Assigns the address of 'x' to the pointer 'ptr'.  'ptr' now points
            at whatever address in memory 'x' has.

            The RHS type of &someIntVariable is actually 'int *' (int pointer)

        - & IN LHS / TYPE DEFINTIONS / VARIABLE DECLARATIONS:
            - used to declare a reference.  & is not the address-of operator in
              these situations.  See the section below on 'type definitions,
              function return types, lvalue references'

        - IN FUNCTION PARAMETERS:

            // parameter 'val' is passed by reference
            void increment(int &val);

            Used to declare a parameter which is a reference type which allows
            the function to modify the caller's variable.  This is closely tied
            to the type definition example.  The parameter in the example above
            is of type 'int reference' and acts as an alias to the variable
            being passed into the function.

        - IN FUNCTION ARGUMENTS:
            When a function definition includes a pointer as a parameter, the
            function expects the corresponding argument to be passed into the
            function call to be an address, so either of the following:

                qualified with the & operator so that the pointer can bind to
                the argument's address

                                        OR

                an existing pointer which has already been pointed at an address


    TYPE DEFINITIONS / FUNCTION RETURN TYPES / LVALUE REFERENCES

        // define 'ref' as a 'reference to int types' and assign it
        // to 'reference' 'x'.  Modifying 'ref' now modifies 'x'
        // and vice-versa
        int &ref = x;

        Defines 'ref' as an 'reference to int types'.  'ref' is now a reference
        (alias if it helps to think of it that way) of 'x'.  This could also be
        a return type for a function.  If the variable it returns to is NOT a
        reference, it will be passed by value (copied) into the variable rather
        than give a reference to the variable.  Declaring a non-const reference
        variable as a reference requires an initializer, you cannot pass an
        rvalue to the RHS of the assignment unless you create an rvalue
        reference.  More on rvalue references below

            // int &x = 10; // throws error
            const int &x = 10; // okay

        Also, a const variable cannot be assigned to a reference which is not
        const qualified as well.  Doing so would 'drop' the const qualifier.

                const int x = 10;
                // int &y = x; // illegal
                const &y = x; // legal


    RVALUE REFERENCES:
        // non const int is a reference to rvalue 5
        int &&rvalueRef = 5;

        // const int is a reference to rvalue 5
        const int &constRef = 5;

        // tying it together
        int &&ref = 5;
        ref = 15;
        int &x = rvalueRef;
        x = 20;
        std::cout << rvalueRef << '\n'; // 20


DECLARING POINTERS
-------------------------------------------------------------------------------
The declaration of pointer follows this syntax:

    type *name;

Note that the asterisk used when declaring a pointer only means that it is a
pointer.  It is not to be confused with the dereference operator which is also
written as an asterisk.  They are two different things represented with the same
sign

* when DECLARING a pointer:
    used to state that the variable is a pointer (type *name)

* AFTER DECLARING a pointer ... dereference operator:
    When you want to get or modify the VALUE of the location in in memory that
    the pointer points to, you use the dereference operator before the variable

        std::cout << *somePointer;

A pointer may point to different variables during it's lifetime as shown in the
example below:

    #define newl '\n';
    int main() {
        int firstValue, secondValue;
        int *myPointer;

        myPointer = &firstValue;
        *myPointer = 10;

        myPointer = &secondValue;
        *myPointer = 20;

        std::cout << firstValue << newl;  // prints 10
        std::cout << secondValue << newl; // prints 20

        return 0;
    }

It is also possible to declare multiple pointers at once:
    int *p1, *p2;


POINTERS AND ARRAYS
-------------------------------------------------------------------------------
An array identifier cannot be reassigned, but the values in it's cells can be
reassigned.

An array identifier is similar to a const pointer with a non const value type.
However, you cannot perform arithmetic on an array like you could with a normal
'read only' const pointer.  (array++ is illegal)

After declaring an arr (int myArr[5] = {0,1,2,3,4}), you can reference the
first item in myArr by using myArr.  myArr always will reference the first item
in the array as it "decays" into a pointer to the first item.  While that
pointer cannot be reassigned to point at another cell, it can be used to
modify a cell in the array: *(myArr + 3) = someNewInt;  It is important to note
that while an array's name can act like a pointer in many contexts, it is not a
pointer itself.  An array cannot be reassigned to point to different addresses,
whereas pointing to different addresses is quite common in pointers.

If you assign a pointer to an array, the pointer points to the first index of
the array.  It is possible to increment the index of the array that the
pointer points to simply by incrementing the pointer by however many
memory cells to increase it by.

Here is an example to demonstrate the above paragraphs:

    int numbers[5] = {}; // could also just write as int numbers[];
    int *p = numbers;

    // p initially points to the first cell (0 index of numbers)
    *p = 10;
    std::cout << "Address of numbers[0]: " << p << '\n';
    std::cout << "Value of numbers[0]: " << *p << '\n';

    // increment the memory location p points to (now it points to cell 2)
    p++;
    *p = 20;
    std::cout << "Address of numbers[1]: " << p << '\n';
    std::cout << "Value of numbers[1]: " << *p << '\n';

    // increment the memory location p points to by assigning it to the memory
    // location of numbers[2]
    p = &numbers[2];
    *p = 30;
    std::cout << "Address of numbers[2]: " << p << '\n';
    std::cout << "Value of numbers[2]: " << *p << '\n';

    // increment memory location p points to by assigning it to memory location
    // of numbers[3]
    p = numbers + 3;
    *p = 40;
    std::cout << "Address of numbers[3]: " << p << '\n';
    std::cout << "Value of numbers[3] " << *p << '\n';

    // assign p back to point to the first cell again
    p = numbers;
    // do not assign p, but use a new pointer to point to where p is pointing to
    // (first cell) + 4 cells to assign 50 to the 5th cell in numbers
    *(p + 4) = 50;
    std::cout << "Address of numbers[4]: " << (p + 4) << '\n';
    std::cout << "Value of numbers[4]: " << *(p + 4) << '\n';

    // prints 10, 20, 30, 40, 50,
    for (int i : numbers) {
        std::cout << i << ", ";
    }

Here is another example to demonstrate the similarities and differences between
arrays and a pointer that points to that array

    int numbers[5] = {10, 20, 30, 40, 50};
    int *p = numbers;

    // a pointer assigned to an array does the same thing as an array
    // The difference is that a pointer can be reassigned, where an array once
    // declared cannot

    // both operations do the same thing
    p[4] = 50000;
    numbers[4] = 50000;

    // both operations do the same thing (modify the first index);
    *p = 100;
    *numbers = 100;

    // the below works
    p++; // increment pointer to point at index 1
    *p = 200;

    // this does not work! (the initialized array identifier cannot be
    // reassigned)
    // numbers++;
    // *numbers = 2000;

    // prints 100, 200, 30, 40, 50000,
    for (int i : numbers) {
        std::cout << i << ", ";
    }

Another example demonstrating the nature of assigning pointers to arrays:

    int arr[] = {0, 1, 2, 3, 4};

    // this doesn't work because '*p' is of type 'int *' and '&arr' is of type
    // 'int (*)[5]'.  'arr' by itself decays into a pointer to the first element
    // of the array, while '&arr' yields a pointer to the address of the entire
    // array.
    // int *p = &arr; // type mismatch

    // this works however, because arr used without the address-of operator
    // decays to a pointer to its first element.
    int *p = arr;

    std::cout << p << '\n';
    std::cout << *p << '\n';

What is meant by 'decays to a pointer'?

    This refers to a rule in C and C++ called 'array to pointer decay'.
    Technically, 'arr' in the above example is of type 'int[5]' yet we can still
    assign it to an 'int *' (pointer to int).  The term 'decay' refers to
    automatic conversion of an expression from one type to another.  In most
    expressions, arrays without the & operator are automatically converted to a
    pointer of its first element (with the restrictions listed above about not
    being able to be reassigned).

Why does '&arr' yield a pointer to the entire array?

    While the 'address-of' operator does return an address, a pointer is really
    just a variable which holds an address.  Therefore, the expression '&x'
    evaluates to a pointer.  Assuming 'y' is of type int, the expression:

        int *x = &y;

    has a RHS and LHS type of 'int *'

    An array without the address-of operator 'decays' to a pointer to the first
    element in its sequence (in most expressions).  With the address-of operator
    in front of it, it evaluates to the address of the entire array, which means
    it is a pointer to the entire array.  The reason it is a pointer to the
    entire array, is because unlike in the 'int *x = &y' example, an array is
    not just a single 'int', but an array of int: 'int[5]'


POINTER INITIALIZATION
-------------------------------------------------------------------------------
Pointers can be initialized to either the address of a variable, or another
pointer or array.

    int myVar;
    int *foo = &myVar;
    int *bar = foo;

Note that in the example above, bar is NOT prefixed with the & address of
operator.  This is because the rvalue is already another int pointer which is
valid.

If you were to try to prefix foo with & when assigning to int pointer bar, it
would throw an error because you would be trying to assign type 'int *' to type
'int **'.  The type 'int **' means a pointer to a pointer...which means that the
pointer has increased the level of indirection by one relative to int *

In this above example, this would work:

    int **bar = &foo;
    // which allows this
    int ***baz = &bar;


POINTERS TO POINTERS / LEVEL OF INDIRECTION
-------------------------------------------------------------------------------
Cpp allows the use of pointers that point to pointers.  The syntax simply
requires an asterisk (*) for each level of indirection in the declaration of the
pointer.

    int a = 5;
    int *b = &a;
    int **c = &b;
    int ***d = &c;
    int ****e = &d

The above could also be written in this way which is much more simple:

    int a = 5;
    int *b = &a;
    int *c = b;
    int *d = c;
    int *e = d;

The reason the pointers needed to be redirected in the first example and not in
the second example is using the address of (&) operator on a pointer gets the
address of where the pointer itself is stored, NOT the address it points to.
Pointer variables themselves are also variables which need to be stored
somewhere.  In the first example, indirection is needed to traverse to map of
addresses because the address of operator was used to get the address of the
pointers.

The example below shows the nature of pointers with multiple levels of
indirection.  The dereference operator only dereferences one level of
indirection.

    int a = 10;
    int *b = &a;
    int **c = &b;
    int ***d = &c;
    int ****e = &d;

    std::cout << &a << '\n'; // same address as b
    std::cout << b << '\n';  // same address as a
    std::cout << c << '\n';  // different address
    std::cout << d << '\n';  // different address
    std::cout << e << '\n';  // different address
    std::cout << "------------------------" << '\n';

    // all print 10
    std::cout << a << '\n';
    std::cout << *b << '\n';
    std::cout << **c << '\n';
    std::cout << ***d << '\n';
    std::cout << ****e << '\n';
    std::cout << "------------------------" << '\n';

    // print the address of a
    std::cout << &****e << '\n';
    std::cout << "------------------------" << '\n';

    std::cout << a << '\n';                // 10
    std::cout << *b << '\n';               // 10
    std::cout << *c << " : " << b << '\n'; // address of b
    std::cout << *d << " : " << c << '\n'; // address of c
    std::cout << *e << " : " << d << '\n'; // address of d
    std::cout << "------------------------" << '\n';


POINTER ARITHMETICS
-------------------------------------------------------------------------------
Only addition and subtraction operations are allowed on pointers (note that we
are not talking about pointers using the dereference operator (*) here. We are
talking about pointers pointing to memory addresses without the dereference
operator, which means we aren't talking about modifying the values the pointers
point to, only the addresses which they point)

Operations aside from addition and subtraction make no sense in the world of
pointers.

Both addition and subtraction have a slightly different behavior with pointers
depending on the size of the data type to which they point

Fundamental data types occupy different sizes of memory.  For example, a char is
always 1 byte (8 bits).  A short is larger than that, and an int and a long are
even larger.  The exact size of these larger than a char takes is dependent on
the system so for the example below these are imagined bytes:

    // image that the below pointers point to memory
    // locations 1000, 2000, 3000 respectively
    // imagine char = 1 byte, short = 2 bytes, long = 4 bytes
    char *myChar;   // pointer to 1000
    short *myShort; // pointer to 2000
    long *myLong;   // pointer to 3000

    // the memory location will increment based on how many bytes each takes up
    ++myChar; ++myShort; ++myLong;

    //      before   | after
    // -----------------------
    // myChar   1000 | 1001
    // myShort  2000 | 2002
    // myLong   3000 | 3004


PRE AND POSTFIX INCREMENT / DECREMENT AND POINTERS
-------------------------------------------------------------------------------
*p++ is equivalent to *(p++) which means: increase the address of pointer p,
and then get the value of the new address

There are 4 possible combinations of the dereference operator with the pre and
post increment operators (and another 4 with the pre and post decrement
operators of course).

Postfix operators have a higher operator precedence than prefix operators which
explains some of the behavior in the examples below:

Here are the possible combinations with the pre/post increment operators
explained.  The same combinations would also apply to the pre/post decrement
operators.

*p++ // same as *(p++) increment pointer, dereference unincremented address
*++p // same as *(++p) increment pointer, dereference incremened address
++*p // same as ++(*p) dereference pointer, increment value it points to
(*p)++ // dereference pointer, post increment the value it points to

A typical but not so simple statement involving these operators is:

    // p and q are both incremented in their respective memory locations
    // but the value that p and q point to are not incremented before
    // p is assigned to q
    *p++ = *q++


The above is roughly equal to:
    *p = *q; ++p; ++q;

If you notice in the above example...

    *p = *q

Right here you might think that because both p and q are dereferenced it would
be like assigning a value to a value (5 = 5) which would throw an error.  But
that is not the case.  Here is an example to demonstrate.

    int myVar = 5;
    int *foo = &myVar;
    int *bar = &myVar;

    // foo points to where bar points to
    foo = bar;

    // reads as: the value of the location foo points to is the value
    // of the of the location bar points to
    *foo = *bar;

    std::cout << *foo << '\n';
    std::cout << *bar << '\n';

Regarding pointer arithmetic, parentheses reduce confusion by adding legibility
to expressions


POINTERS AND CONST
------------------------------------------------------------------------------
Pointers can be used to access a variable by its address, and this access may
include modifying the value pointed.  It is also possible to declare pointers
that can access the pointed value to read it, but not modify it.

To declare a pointer that can access a value to read a variable, but not modify
it, use qualify it with const:

    int x = 5;
    int y = 10;

    const int *p = &x;
    // *p = 25; // read only variable is not assignable

    // You cannot modify the value the p points to
    // But you can modify the location is points to
    p = &y; // this is valid

    // You can also modify the the value of the location p points to
    // but not directly through p as, again, p is read only
    y = 25;

    std::cout << *p; // prints 25

One of the use cases of point to const element is as function parameters.  A
function that takes a point to a non-const as a parameter can modify the value
passed as an argument, while a function that takes a pointer const as a
parameter cannot.

In the example below, remember that a pointer qualified with const CAN change
where it points to.  It just can't modify where it points to.

    #include <iostream>

    void incrementAll(int *start, int *stop) {
        int *current = start; // current points to where start points

        // while the address of current != the address of stop
        while (current != stop) {
            ++(*current); // increment value current points to
            ++current;    // increment pointer
        }

        std::cout << '\n';
        std::cout << "Memory address of current and stop are the same: " << '\n';
        std::cout << "Current: " << current << '\n';
        std::cout << "Stop: " << stop << '\n';
    }

    void printAll(const int *start, const int *stop) {
        const int *current = start;

        // we can still modify the location current points to
        // but we cannot modify the value current points to
        // this is okay though, because we are just printing the
        // values in an array
        while (current != stop) {
            std::cout << *current << '\n';
            ++current;
        }
    }

    int main() {
        int numbers[] = {10, 20, 30};
        std::cout << "Memory addresses of all cells in the numbers array:" << '\n';

        for (int i = 0; i < 4; i++) {
            std::cout << "Cell " << i << ": " << numbers + i << '\n';
        }

        incrementAll(numbers, numbers + 3);
        printAll(numbers, numbers + 3);

        return 0;
    }

While const pointers are read only pointers that can be modified, pointers
themselves can also be const which is closer to the JavaScript implementation
than the examples above.  Here is an example to explain:

    int x = 5;

    // NON-CONST POINTER TO NON-CONST VALUE
    // CAN change where the pointer points to
    // CAN change the value of the memory address it points to
    int *p1 = &x;

    // NON-CONST POINTER TO CONST VALUE
    // CAN change where the pointer points to
    // CANNOT change the value of the memory address it points to
    const int *p2 = &x;     // const before the type
    int const *p2_alt = &x; // const after the type

    // CONST POINTER TO NON-CONST VALUE
    // CANNOT change where the pointer points to
    // CAN change the value of the memory address it points to
    int *const p3 = &x;

    // CONST POINTER TO CONST VALUE
    // CANNOT change where the pointer points to
    // CANNOT change the value of the memory address it points to
    const int *const p4 = &x;     // const before the type
    int const *const p4_alt = &x; // const after the type

    /* NOTE: For pointers to const values, you can swap the position of const
     * and type without changing the meaning.  However, for making the pointer
     * itself const, this flexibility does not extend */


POINTERS AND STRING LITERALS
-------------------------------------------------------------------------------
String literals are just arrays containing null-terminated character
sequences.

String literals can be inserted directly into std::cout to initialize strings
and initialize arrays of chars.

String literals can also be accessed directly.  However each of the elements in
a string literal are of type const char, so they cannot be modified.

In the example below, we declare an array with the literal representation for
"hello", and then a pointer to its first element named "foo".  Then we loop over
each cell in the string literal (which is just an array that is terminated with
a null character) and log each character on the same line.  In each iteration,
we increment the foo pointer location by 1, then check the value foo points to
against the condition in the while loop.

    const char *foo = "hello";

    while (*foo != '\0') {
        std::cout << *foo;
        foo++;
    }


VOID POINTERS
-------------------------------------------------------------------------------
The void pointer is a special type of pointer in cpp that represents the absense
of a type.  Therefore, void pointers are pointers that point to a value that has
no type and thus also an undetermined length and undetermined dereferencing
properties.

Void pointers can point to any data type.  However, the data they point to
cannot be directly dereferenced since we have no type to dereference to.  You
cannot increment or decrement a void pointer either because it has no type to
know how many bytes to increment or decrement it's new location in memory to
point to!

Because void pointers cannot be directly dereferenced, they need to be
transformed into some other pointer type that points to a concrete data type
before being dereferenced.

Void pointers are used when a function needs to accept multiple types of data
pointers, and the specific type might not be known at compile time.

    void increase(void *data, int psize) {

        // if psize == the size in bytes of type 'char'
        if (psize == sizeof(char)) {

            // 'transform' data into another pointer that points to where
            // data points but as type 'char'
            char *pchar = (char *)data;

            // increment the value that pchar points to
            // incrementing a char increments it alphabetically 'a' -> 'b'
            ++(*pchar);

            return;
        }

        // if psize == the size in bytes of type 'int'
        if (psize == sizeof(int)) {

            int *pint = (int *)data;
            ++(*pint);

            return;
        }
    }

    int main() {
        char a = 'a';
        int b = 1602;

        increase(&a, sizeof(char));
        increase(&b, sizeof(int));

        std::cout << a << ", " << b << '\n'; // b, 1603
        return 0;
    }

The above example, was an example of type casting and was C-style cast.  Cpp
provides other, more specific types of casts as well, which are safer and more
readable.  More on that below a couple sections...


POINTERS AS PARAMETERS
-------------------------------------------------------------------------------
In the example above with void pointers, you may have noticed that the function
definition uses a void pointer called data in its first argument, but then we
pass a parameter into the function using the & address of operator which may be
confusing.  The principle of passing the address of a variable to a function
that expects a pointer as an argument is applied universally in cpp (and c), not
just with void pointers.  An address or a valid pointer which has already been
defined are both valid to use in function arguments where a pointer is expected.

To define a pointer the syntax reads:

    // pointer type points to the address of variable
    type *name = &variable;

It is therefore easy to make the connection of why you pass the variable address
in the function call, but pass a pointer in the function definition.  However,
the relationship should still be clearly stated because in most other
programming paradigms, the parameters in the function call are of the same type
as in the function definition.

This approach allows the function to directly access and modify the caller's
variable.



MORE SPECIFIC TYPES OF TYPE CASTING
-------------------------------------------------------------------------------
In the example of using void pointers a couple sections up, we used what is
known as type casting, and in particular, c-style type casting.

Cpp also provides other, more specific types of casts as well which are safer
and more readable:

    static_cast<type *>(someVoidPointer);

    dynamic_cast<type *>(someVoidPointer);

    reinterpret_cast<cast *>(someVoidPointer);

    const_cast<type *>(someVoidPointer);

The example given with the increase function could have written type casts like
so:
    char *pchar = static_cast<char *>(data);
    int *pint = static_cast<int *>(data);

You cannot increment or decrement a void pointer without typecasting it to a
type!  Otherwise it doesn't now how far to increment or decrement in memory.  We
need to typecast it so it knows.  This was stated in the section on void
pointers as well but I feel it is important to the understanding of why void
pointers need to be typecasted.


INVALID POINTERS
-------------------------------------------------------------------------------
While pointers are meant to point to valid memory addresses, they can actually
point to any address, even addresses that do not refer to any valid element!
Typical examples of this are unitialized pointers and pointer to non-existent
elements of an array.  These uninitialized pointers and pointers to non-existent
elements of an array do not throw errors.

In the example below, none of these throw errors, but the bottom two std::cout
statements do show that invalid pointers behave unpredictably, and therefore
could crash a program just like an error would.

    int myArray[10];
    int *p = myArray + 5;

    *p = 50;
    std::cout << *p << '\n';  // 50

    p = myArray + 20; // pointer is out out of bounds of the array
    *p = 50;


    std::cout << *p << '\n'; // 50
    std::cout << *(myArray + 20) << '\n'; // 50

    p++
    std::cout << *p << '\n'; // some random number

    int *q;
    std::cout << *q << '\n'; // some random number


NULL POINTERS
-------------------------------------------------------------------------------
Sometimes a pointer really needs to explicitly point to nowhere, and not just an
invalid address.  For those cases, there exists a special value that any pointer
type can take: null pointer value

Null pointers can be expressed in two ways:

    // With an integer value of zero
    int *p = 0;

    // with the nullptr keyword
    int *q = nullptr;

In these two examples, p and q are both null pointers, meaning that they
explicitly point to nowhere.

All null pointers compare equal to other null pointers.

It is possible see the defined constant NULL be used in older code to refer to
the null pointer value. Since NULL is defined in several headers of the std
library and is defined as an alias of some null pointer constant values such as
0 or nullptr, it can be used in place of 0 or nullptr.

Accessing the address of a nullptr is valid.  It evaluates to 0.

    int *p = nullptr;
    std::cout << p << '\n'; // 0

However accessing the value of a nullptr will lead to a segmentation fault.

    int *p = nullptr;
    std::cout << *p << '\n'; // segmentation fault (core dumped)

Important note on null pointers vs void pointers:
    A null pointer is a value that any pointer can take to represent that it is
    pointing to NOWHERE

    A void pointer is a type of pointer that can point to ANYWHERE, but it lacks
    a specific type.  In order to use the data it points to (such as
    dereferencing it), it must be typecasted to a specific type.

    Null pointers indicate that the pointer does not hold a valid address.

    Void pointers are about the pointers type flexibility.  A void pointer can
    point to any data through type casting but lacks specific type information.


POINTERS TO FUNCTIONS
-------------------------------------------------------------------------------
Cpp allows operations with pointers to functions.  The typical use of this is
for passing a function as an argument to another function (callback functions).

The syntax for creating a pointer to a function is:

    returnType (*pointerName)(someFnArg1, someFnArg2...) = someFn;

Here is an example to demonstate:

    int addition(int a, int b) {
        return a + b;
    }

    int subtraction(int a, int b) {
        return a - b;
    }

    int operation(int x, int y, int (*callback)(int, int)) {
        // the return statement could also be written as:
        // return callback(x, y);
        // Cpp allows a function pointer to be called without
        // explicitly dereferencing it
        return (*callback)(x, y);
    }

    int main() {

        int (*minus)(int, int) = subtraction;

        int m = operation(6, 5, addition);

        // could also just pass subtraction instead of minus
        // as was done with addition
        int n = operation(20, m, minus);

        std::cout << m << ", " << n << "\n"; // outputs: 11, 9

        return 0;
    }


-------------------------------------------------------------------------------
DYNAMIC MEMORY
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/dynamic/
-------------------------------------------------------------------------------
"DYNAMIC MEMORY is to the HEAP as AUTOMATIC MEMORY is to the STACK / STATIC
MEMORY"

AUTOMATIC MEMORY / STACK ALLOCATION / STATIC MEMORY (the data segment)
-------------------------------------------------------------------------------
To understand dynamic memory, you need to understand what STACK ALLOCATION is.

Anytime you declare a variable like you normally would in cpp, the memory for
that variable is automatically allocated to the STACK.  This type of allocation
does not require explicit deallocation, as the memory is automatically freed
when the variable goes out of its scope.

However, static and global variables (need more on static variables) are NOT
automatically allocated to the stack at the start of a program.  Static and
global variables are automatically allocated to an area of memory called STATIC
MEMORY and are automatically deallocated from STATIC MEMORY at the end of a
program.  STATIC MEMORY is also referred to as THE DATA SEGMENT.


DYNAMIC MEMORY / HEAP ALLOCATION
-------------------------------------------------------------------------------
Anytime you dynamically allocate memory, the memory block goes on the HEAP. To
allocate memory on the HEAP, you need to use pointers in conjunction with the
new / new[] (for allocation) and delete / delete[] (for deallocation).  You
cannot access memory on the heap without pointers, so pointers are required to
access and interact with this heap memory.

    pointer = new type;
    pointer = new type[number_of_elements];

    // this is incorrect
    // you MUST use pointers when dynamically allocating memory
    // on the heap with new or new[]
    myVar = new int;

    // it should be written as
    int *myVar = new int;
    // or
    int *myVar = new int(5);
    // or
    int *myVar = new int{5}

Dynamic memory using pointers gives the programmer the freedom to control memory
blocks for any desired duration, whereas automatic memory restricts this freedom
by automatically allocating and deallocating memory based on scope.

For every 'new' operation, there should be a corresponding 'delete' operation so
as to avoid memory leaks.


THE 'NEW' KEYWORD CHANGES THE ADDRESS POINTERS POINT TO
-------------------------------------------------------------------------------
It is important to understand that a pointer which has not allocated memory on
the heap yet points to a memory location which is allocated for automatic
memory.  When you use the new keyword to dynamically allocate memory on the
heap, if the request is granted, the pointer now points to that memory location
on the heap, not where it previously pointed to.

This might not seem like a big deal at first, but consider these points:

    Pointers, just like any variable, have their own memory address.  The
    distinction between a pointer and a regular variable, is that pointers point
    at a different memory address than the one they are assigned.  While pointer
    a and pointer b may be equal in a conditional equality check, they are not
    stored in the same location in memory.  They merely point to the same
    address.

    When a function expects a pointer as an argument, the pointer will be passed
    by value (copied) into the local scope of the function, UNLESS the function
    declaration explicitly defines the pointer as a reference in the parameters.

Considering the above, if we were using functions to dynamically allocate memory
and we want the dynamic memory to be able to be accessed outside the scope of
the function, pointers must be passed as reference.  Otherwise, we essentially
'lose' the memory.  The pointer we want to continue using is copied in the
function and destroyed at the finality of the function's scope.

    // pointer p is passed by value
    void pointerTestCopy(int *p) {
        // print address of p
        std::cout << "p copy address: " << p << '\n';

        // allocate new int to the heap
        p = new int(10);

        // print address of p after allocating to the heap
        std::cout << "p copy address after allocating: " << p << '\n';
    }

    // pointer p is passed by reference
    void pointerTestRef(int *&p) {
        std::cout << "p ref address: " << p << '\n';
        p = new int(10);
        std::cout << "p ref address after allocating: " << p << '\n';
    }

    int main() {

        int *p1 = nullptr;

        std::cout << "p1 address before copy: " << p1 << '\n'; // 0 (null)
        pointerTestCopy(p1);
        std::cout << "p1 address after copy: " << p1 << '\n'; // 0 (null)

        std::cout << "----------------------------" << '\n';

        int *p2 = nullptr;
        std::cout << "p2 address before: " << p2 << '\n'; // 0 (null)
        pointerTestRef(p2);
        // prints the same address after it was allocated
        // in the local scope of the pointerTestRef function
        std::cout << "p2 address after: " << p2 << '\n';

        // Trying to dereference a pointer to null causes a
        // segmentation fault.  This means none of the code aferwards
        // will run and this demonstrates the importance of passing
        // by reference in functions which allocate dynamic memory.

        // causes no errors (p2 was modified by being passed by reference
        // in the pointerToRef function which dynamically allocated memory
        // using a reference to p2)
        std::cout << *p2 << '\n'; // 10

        // causes a segmentation fault (p1 still points to null)
        std::cout << "value of p1: " << *p1 << '\n';

        std::cout << "This will not be executed" << '\n';

        return 0;
    }


MEMORY LEAKS WITH DYNAMIC MEMORY
-------------------------------------------------------------------------------
After a program is terminated, modern Operating Systems automatically reclaim
memory allocated by a program, including any leftover memory blocks that were
not properly deallocated.  Poor memory management will not effect the RAM of a
computer after the termination of the program.

However, by forgetting to free dynamically allocated memory, the memory is now
wasted until the program terminates.  This is what is known as a memory leak.
This is not always an issue, especially with modern computers where there is
plenty of RAM to run most programs.  This can be an issue though if you have
a cpp program that runs for a long time and continues to leak memory.  While the
program is running, you will be depleting available RAM which can be a
significant issue depending on how long the program runs or the how much RAM the
host OS has.  Imagine a program that runs an infinite while loop that does not
properly deallocate memory.  Eventually, this program would lead to total
depletion of available RAM if ran long enough.


NEW AND NEW[]
-------------------------------------------------------------------------------
To allocate memory onto the heap, use the following syntax:

    // 1: pointer = new type;
    int *foo = new int;
    *foo = 5;
    // or
    int *foo = new int(5);
    // or
    int *foo = new int{5};

    // 2: pointer = new type [number_of_elements];
    int *bar = new int[5];
    // or
    int *bar = new int[5]{0, 1, 2, 3, 4};

The second example dynamically allocates space for five elements of type int and
the syntax 'new int[5]' returns a pointer to the first element of the sequence
which is assigned to the pointer 'bar'.

There is an important distinction between declaring a normal array and
allocating dynamic memory for a block of memory using new (as was done in the
above example with bar).  The most important difference is that the size of a
regular array needs to be a constant expression, and thus its size must be
determined before the program is run.  However, the dynamic memory allocation
performed by new allows you to assign memory during runtime using a variable
value as size.  This will be shown in an example in the DELETE AND DELETE[]
section.

The dynamic memory requested from the heap is NOT gauranteed to be fulfilled.
This is because computer memory is a finite resource and can therefore be
depleted.  Cpp provides two standard mechanisms to check if the allocation was
successful or not:
    1. Exception of type 'std::bad_alloc' is thrown when an allocation fails.
    This terminates the program, unless it is handled by a specific handler.
    2. The nothrow method.  It is declared in the header <new> as an argument
    for the new keyword.  If the allocation fails, the new keyword returns a
    null pointer and the program continues it's execution normally.

        // example of using nothrow
        int *foo = new (nothrow) int [5];
        if (foo == nullptr) { // error assigning memory }

Note: handling exceptions is generally more efficient than using the nothrow
method.

Note: the delete operator has no effect on a null pointer


DELETE AND DELETE[]
-------------------------------------------------------------------------------
To deallocate memory onto the heap, use the following syntax:
    delete pointer;
    delete[] pointer;

The first statement releases the memory of a single element.
The second statement releases the memory allocated for arrays.


NEW AND DELETE EXAMPLES
-------------------------------------------------------------------------------

    // example using new, delete, and nothrow

    #include <iostream>
    #include <new>

    int main() {
        int input;

        std::cout << "Enter how many numbers you would like to type: ";
        std::cin >> input;

        // attempt to allocate as many int memory blocks for
        // the array as the user inputs
        int *numbers = new (std::nothrow) int[input];

        // if the new keyword in the above returns
        // a null pointer
        if (numbers == nullptr) {
            std::cout << "Error: Memory could not be allocated.\n";
            std::cout << "The user may have entered a number too large.";
            return 0;
        }

        // the new keyword has successfully allocated memory
        for (int i = 0; i < input; i++) {
            std::cout << "Enter number: ";
            std::cin >> numbers[i];
        }

        for (int i = 0; i < input; i++) {
            std::cout << numbers[i] << ", ";
        }

        delete[] numbers;

        return 0;
    }

-------------------------------------------------------------------------------

    // example using new and delete on an array

    int *arr = new int[5]{0, 1, 2, 3, 4};
    for (int i; i < 5; i++) {
        std::cout << arr[i] << " ";
    }
    delete[] arr;


SMART POINTERS
-------------------------------------------------------------------------------
Modern cpp introduces smart pointers such as:
    std::unique_ptr
    std::shared_ptr
    std::weak_ptr

These smart pointers manage dynamic memory automatically and they are
prefereable to raw pointers in most use cases because they help avoid common
memory management pitfalls.

    // myInt is a pointer to new int(10)
    int *myInt = new int(10);
    // can also be written int *myInt = new int{10};

    // cout the dereferenced myInt
    std::cout << *myInt << "\n";

    // delete the stored data in the memory location that myInt points to
    delete myInt;

    // make a unique pointer "smartInt" to a new int with a value of 20
    std::unique_ptr<int> smartInt = std::make_unique<int>(20);

    // cout the dereferenced smartInt
    std::cout << *smartInt << "\n";


WHY USE DYNAMIC MEMORY
-------------------------------------------------------------------------------
1. Allows you to allocate memory as needed at runtime.  This is particularly
relevant when the memory needed is dependent on user input.

2. Programs can use system resources more efficiently by allocating and
deallocating only when necessary.

3. With very large objects, dynamic memory can help avoid stack overflow, which
is a common issue with automatic memory allocation.

4. Dynamically allocated memory can persist beyond the scope it was allocated
in, which allows for more flexibility.

5. It is crucial for working with tree-like data structures and linked lists,
which inherently involve objects pointing to each other in a non linear fashion.
Using automatic memory (stack) memory for these data structures could lead to
issues with the scope and lifetime of nodes, because automatic variables are
destroyed when they go out of scope.  Trees and linked lists may need objects to
persist beyond the scope in which they were created.  The nature of dynamically
allocated memory existing for the duration of a program unless explicitly
deallocated by the programmer make dynamic memory crucial to the stability of
tree like data structures.


DYNAMIC MEMORY IN C
-------------------------------------------------------------------------------
Cpp integrates the operators new and delete for allocating dynamic memory, but
these were not available in the C language.  Instead, C used a library solution,
with the functions:
      malloc
      calloc
      realloc
      free
which are defined in the <cstdlib> (known as <stdlib.h> in C).

These functions are also available in cpp and can also be used to allocate and
deallocate dynamic memory.  Note, that the memory blocks allocated by these
functions are not necessarily compatible with those returned by new, so these
should not be mixed


-------------------------------------------------------------------------------
DATA STRUCTURES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/structures/
-------------------------------------------------------------------------------
A data structure is a group of elements grouped together under one name.  These
data elements are known as members and can have a different type and different
lengths.  Data structures can be declared in cpp using the following syntax,
which is very similar to the Interface syntax in TypeScript:

    struct type_name {
        member_type1 member_name1;
        member_type2 member_name2;
        member_type3 member_name3;
    } object_names;

Here is an example:

    struct Product {
        int weight;
        double price;
    } pear;

    // pear has already been initialized
    pear.price = 100000;
    pear.weight = 220;

    // initialize apple
    Product apple;

    apple.price = 5.50;
    apple.weight = 10;

    std::cout << pear.price << "\n";
    std::cout << pear.weight << "\n";

    std::cout << apple.price << "\n";
    std::cout << apple.weight << "\n";

Note how in the example above, product becomes a type and the identifiers pear
and apple are both of type 'product'.  Also note how pear was defined right
after the curly braces, but apple was defined later in the code.  Both of these
are valid.

    #include <iostream>
    #include <sstream>

    struct Movie {
        std::string title;
        int year;
    };

    void printMovie(Movie movie);

    int main() {

        Movie cpuMovie;
        cpuMovie.title = "The Bridge on the River Kwai";
        cpuMovie.year = 1957;

        Movie userMovie;
        std::cout << "Enter your movie brah: ";
        std::getline(std::cin, userMovie.title);

        std::string userYear;
        std::cout << "Enter the movie year brah: ";
        std::getline(std::cin, userYear);
        std::stringstream(userYear) >> userMovie.year;

        std::cout << "Well thats a terrible choice brah"
                  << "\n\n";
        std::cout << "My favorite movie is: \n";
        printMovie(cpuMovie);
        std::cout << "...and yours is: \n";
        printMovie(userMovie);

        return 0;
    }

    void printMovie(Movie movie) {
        std::cout << "\t" << movie.title;
        std::cout << " (" << movie.year << ")"
                  << "\n";
    }

-------------------------------------------------------------------------------

    #include <iostream>
    #include <sstream>
    #include <string>

    struct Movie {
        std::string title;
        int year;
    };

    void printMovie(Movie movie);

    int main() {
        int moviesLength = 3;
        Movie movies[moviesLength];

        for (int i = 0; i < moviesLength; i++) {
            std::cout << "Enter a title brah: ";
            std::getline(std::cin, movies[i].title);

            std::string year;
            std::cout << "Enter da year brah: ";
            std::getline(std::cin, year);
            std::stringstream(year) >> movies[i].year;
        }

        std::cout << "\nBrah you have entered these movies:\n";
        for (int i = 0; i < moviesLength; i++) {
            printMovie(movies[i]);
        }

        return 0;
    }

    void printMovie(Movie movie) {
        std::cout << "\t" << movie.title << " (" << movie.year << ")\n";
    }

POINTERS TO STRUCTURES
-------------------------------------------------------------------------------
You can create a pointer to a structure just like you would any other type
because remember, structures are essentially just user defined compound types.

When you access members of a structure with a pointer, you use the arrow
operator -> . With the arrow operator -> , you are essentially replacing the .
with a -> to access members of the struct.  The reason you can do this is
because the arrow operator is a dereference operator.  It dereferences the
pointer and then accesses a member, which combines the functionality of the
dereference operator (*) and the member access operator (.) in one step.

    #include <iostream>
    #include <sstream>

    struct Movie {
        std::string title;
        int year;
    }; // remember to add a semicolon here!

    // Takes in a Movie instance.  Unlike JavaScript, which
    // automatically will pass a compound data structure by
    // reference, cpp will pass the Movie instance in this
    // function by value and thus make an entire copy
    void printMovie(Movie movie);

    // This code passes a const reference to to the Movie instance,
    // and thus does not copy the entire structure and cannot modify
    // the Movie instance either.  This is similar to how it is
    // done in JS (minus the const part).  In the case of this example,
    // this function is the most practical.
    void printMovieReference(Movie &movie);

    // Takes in a const pointer, so this function cannot
    // modify the Movie instance it points to and it also
    // does not make create a copy
    void printMoviePointer(const Movie *pMovie);

    int main() {

        Movie movie;
        Movie *pMovie = &movie;

        std::cout << "Enter title: ";
        std::getline(std::cin, pMovie->title);

        // This would be invalid
        // std::getline(std::cin, *pMovie.title);

        // This would be valid, however is unconventional
        // std::getline(std::cin, (*pMovie).title);

        std::string year;
        std::cout << "Enter year: ";
        std::getline(std::cin, year);
        std::stringstream(year) >> pMovie->year;

        // this code copies the entire movie
        // printMovie(movie);

        // this code does not copy the entire movie
        // printMovieReference(movie);

        // this code does not copy the entire movie either
        printMoviePointer(&movie);

        return 0;
    }

    void printMovie(Movie movie) {
        std::cout << "\t" << movie.title << " (" << movie.year << ")\n";
    }

    void printMovieReference(Movie &movie) {
        std::cout << "\t" << movie.title << " (" << movie.year << ")\n";
    }

    void printMoviePointer(const Movie *pMovie) {
        std::cout << "\t" << pMovie->title << " (" << pMovie->year << ")\n";
    }


NESTING STRUCTURES
-------------------------------------------------------------------------------
Structures can also be nested within other structures:

    struct Movie {
        std::string title;
        int year;
    };

    struct Friend {
        std::string name;
        std::string email;
        Movie favoriteMovie;
    } charlie, maria;

    int main() {
        Friend *pFriend = &charlie;
        pFriend->favoriteMovie.year = 1975;
        std::cout << pFriend->favoriteMovie.year;

        return 0
    }

In the above example, favoriteMovie.year still uses dot notation because the
favoriteMovie Movie object is not itself a pointer.  To legally use the arrow
operator on the favoriteMovie property, we would have to modify the modify the
main function statements like so.  In addition, we would need to make the
favoriteMovie property in the friend definition a pointer to Movie objects.

    struct Movie {
        std::string title;
        int year;
    };

    struct Friend {
        std::string name;
        std::string email;
        Movie *favoriteMovie;
    } charlie, maria;

    int main() {
        Friend *pFriend = &charlie;
        Movie drZhivago;
        Movie *pMovie = &drZhivago;
        pMovie->title = "Dr Zhivago";
        pFriend->favoriteMovie = pMovie;
        pFriend->favoriteMovie->year = 1975;
        std::cout << pFriend->favoriteMovie->year << '\n';
        std::cout << pFriend->favoriteMovie->title << '\n';
    }


-------------------------------------------------------------------------------
OTHER DATA TYPES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/other_data_types/
-------------------------------------------------------------------------------

TYPE ALIASES ( TYPEDEF / USING )
-------------------------------------------------------------------------------
A type alias is a different name by which a type can be identified.  In cpp, any
valid type can be aliased so that it can referred to with a different
identifier.  For example, say you are too lazy to type the type char every time
you wanted to declare a new variable of type char, you could create an alias for
the char type with the typedef keyword or the using keyword.

The syntax is:

typedef existing_type new_type_name;
using new_type = existing_type;

    // example
    typedef char C;
    typedef unsigned int WORD;
    typedef char *pChar;
    typedef char field[50];

    // can also be written using the using syntax
    using C = char;
    using WORD = unsigned int;
    using pChar = char*;
    using field = char[50];

Once these aliases are defined, they can be used in any declaration just like
any other valid type:

    // declare char identifiers
    C myChar, anotherChar, *pToChar1;

    // declare unsigned int identifier myWord
    WORD myWord;

    // declare pToChar2 which is a pointer to chars
    pChar pToChar2;

    // declare name, which is an array of 50 chars
    field name;

The only differences between the using and typedef keywords is that typedef has
certain limitations in the realm of templates that using does not have.  using
is more generic, but typedef has a long history and is probably more common in
existing code.

For clarification, neither using nor typedef create new distinct data types.
They only create aliases (synonyms) for existing types.

Type aliases can be used to reduce the length of long or confusing type names,
or to abstract programs from the underlying types they use.

As an example of how this may be helpful; say your program needs to be of a
particular type of parameter which (for simplicity purposes) could be either an
int or a long.  Simply create an alias for the type to be passed.  That way if
you decide the change the type later on, its as simple as changing the alias,
rather than finding and changing every instance of that specified type to the
new type.  Not only would it be a pain to manually edit every type, but there
would be likely be variables not designed to be of this 'either int or long'
type which would make it easy to make a mistake.


UNIONS
-------------------------------------------------------------------------------
Unions allows one portion of memory to be accessed as different data types.
It's declaration and use is similar to that of structures, but its functionality
is entirely different.

Unions are useful when you need to work with different data types in a context
where you're sure only one type is used at a time, and you want to save memory.
This is especially useful is low-level programming and performance critical
software where memory usage is critical. Some common uses are:

    hardware register access

    protocol message handling

    variant datatypes where the actual data type might change dynamically, but
    only one value is stored at any time

The largest member of the union is the size of the union's allocated memory
block.

If you don't know what type of data you want to use, the union is a good data
structure, as it allows you to essentially overwrite whatever type you no longer
want to use and gives you freedom over the type you are using

    union MyTypes {
        char c;
        int i;
        float f;
    } mix;

    // when one member in a union changes, all of them do.

    mix.c = 'a';
    mix.f = 3.14;
    mix.i = 5;

    // logs 5
    std::cout << mix.i << '\n';

    // these last two examples show how accessing a union member
    // other than the last one written leads to undefined behavior

    // the compiler tries to interpret the bits that represent an
    // int that stores 5, but as a a float...so this is for
    // demonstration purposes and is impractical in nature
    std::cout << mix.f << '\n';

    // logs nothing in this case, but the compiler still tries
    // to interpret the bits that represent an int with the value
    // of 5 as a char
    std::cout << mix.c << '\n';


ANONYMOUS UNIONS
-------------------------------------------------------------------------------
When unions are members of a class (or structure), they can be declared with no
name.  In this case they become anonymous unions.

Here are two examples where a union is defined within a structure.  One of the
unions is a regular union, and the other is an anonymous union.

    // with regular union
    struct Book1 {
        char title[50];
        char author[50];

        union {
            float dollars;
            int yen;
        } price; // initialize price as this Union's name
    } book1; // initialize book1 as an instance of Book1

    // with an anonymous union
    struct Book2 {
        char title[50];
        char author[50];

        union {
            float dollars;
            int yen;
        }; // no name given, this is what makes this union anonymous
    } book2;

    // NOT anonymous union
    book1.price.dollars = 1.50;

    // anonymous union
    book2.dollars = 1.50;

In the example above, the same rules form regular unions still apply.  Remember
that the union members dollars and yen actually share the same memory location,
so the cannot be used to store two different values simultaneously.  The price
can be set in dollars, or in yen, but not both simultaneously.  As far as code
readability goes, the example without an anonymous union is probably more
readable since you know that dollars and yen refer to a price, but readability
wasn't the purpose of this example.


ENUMERATED TYPES ( ENUM )
-------------------------------------------------------------------------------

    enum TypeName {
        value1,
        value2,
        value3,
    } objectNames;

    TypeName newObjectName;
    newObjectName = value1;

Enums essentially create an entirely new data type from scratch without basing
it on any other existing type.  The possible values for the enum type will be
only the enumerators listed inside curly braces within the enum type definition.

What is going on behind the hood, is that the enumerated type is coupling the
members to ints.

    enum Colors { black, blue, green = 50 } myColor;
    // black = 0, blue = 1, green = 50
    // note: Assigning int 50 to green is for demonstration purposes.
    // Most uses cases will probably not utilize modifying the values

    myColor = Colors::blue;
    if (myColor == Colors::blue) {
        // do some stuff that you should only do when myColor is blue
    }

The values enumerated types declared with enum are implicitly convertible to an
integer type.  You can also explicitly state the underying type of an enum
with the syntax below:

    enum Colors : char { black = 'a', blue = 'b', green } myColor;
    // black = a, blue = b, green = c (even though it wasn't explictly assigned)

    myColor = Colors::green;

    // The above can also be written without the Colors:: prefix, but
    // this makes it less readable
    // myColor = green;

    std::cout << myColor << '\n';
    std::cout << Colors::green << '\n';


ENUM CLASS
-------------------------------------------------------------------------------

    enum class Colors { black, blue, green, cyan, red, purple };

With the enum class it is possible to create types that are neither implicitly
convertable to int, and that neither have the enumerator values of type int, but
of the enum type itself.

This would be helpful if in your program you wanted to do something specific for
specific options:

    enum class Weather { sunny, cloudy, rainy, snowy };

    Weather weather = Weather::sunny;
    weather = Weather::snowy;
    weather = Weather::sunny;

    if (weather == Weather::sunny) {
        std::cout << "You should probably wear some sunglasses bro!";
    }

    // these throw errors because plain enum types are not able to
    // be converted to strings
    // std::cout << weather;
    // std::cout << Weather::cloudy;

Enum types can also control their underlying type.  The underlying type may be
any integral data type such as a char, short, or unsigned int.

    enum class Weather : char { sunny, cloudy, rainy, snowy };

In this example, Weather is a distinct type with the same size of a char (1
byte).  You still cannot do: std::cout << Weather::sunny;


-------------------------------------------------------------------------------
CLASSES (I)
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/classes/
-------------------------------------------------------------------------------
Classes are an expanded concept of data structures.  They can contain data
members, but they can also contain functions as members.

An object is an instantiation of a class.  A class would be the type, and the
object would be the variable.

Classes are defined using either keyword class or the keyword struct, with the
following syntax.

    class ClassName {
        accessSpecifier1;
            member1;
        accessSpecifier2;
            member2;
        ...
    } objectNames;

Classes have the same format as plain data structures, except they can also
include functions and these new things called access specifiers.  An access
specifier is one of the following three keywords:

    private
    public
    protected

The specifiers modify the access rights for the members that follow them.

Private:
    Private members of a class are accessible only from within other members of
    the same class (their 'friends').

Protected:
    Protected members of a class are accessible from other members of the same
    class but also members of their derived classes.

Public:
    Public members are accessible from anywhere the object is visible.


By default, all members of a class declared with the class keyword have private
access for all it's members.  Therefore, any member that is declared before any
access specifier has private access automatically.

The class name becomes the type of each instance of that class

The example below reintroduces the scope operator (::) which also relates to
namespaces.  The scope operator in this case is used to specify that the
function being defined is a member of the Rectangle class and not a non-member
function.

Examples:
-------------------------------------------------------------------------------

    class Rectangle {
        int width, height;

      public:
        void setValues(int, int);
        int getArea();
    };

    void Rectangle::setValues(int x, int y) {
        width = x;
        height = y;
    }

    int Rectangle::getArea() {
        return width * height;
    }

    int main() {

        Rectangle rect;
        rect.setValues(5, 10);
        std::cout << rect.getArea() << '\n'; // logs 50

        return 0;
    }

-------------------------------------------------------------------------------

    // does the same thing as in the example above but without
    // the scope operator

    #include <iostream>

    class Rectangle {
        int width, height;

      public:
        void setValues(int x, int y) {
            width = x;
            height = y;
        }

        int getArea() {
            return width * height;
        }
    };

    int main() {

        Rectangle rect;
        rect.setValues(5, 10);
        std::cout << rect.getArea() << '\n'; // logs 50

        return 0;
    }

-------------------------------------------------------------------------------

    // you could also give default values for height and width

    class Rectangle {
        int width = 5;
        int height = 10;

        // ... rest of the code
    };

Classes allow programming using OOP paradigms.  Data and functions are both
members of the object, which reduce the need to pass and carry handlers or other
state variables as arguments to functions.  In the getArea method from the above
examples, no arguments were passed because the member function was able to
directly access and use the data members of its respective class.  The ability
to not pass as many parameters is just one of the benefits of OOP as it reduces
mental overhead.


MORE ON DECLARING MEMBER FUNCTIONS WITHIN VS OUTSIDE OF CLASS DEFINITIONS
-------------------------------------------------------------------------------
The only difference between declaring a member function completely within the
class definition or just including its declaration and later defining it outside
of the class, is that in the first case the function is automatically considered
an 'inline' member function by the compiler, while in the second it is a normal
'not implicitly inline' class member.

It might be more readable to see all of the member function prototypes compacted
within the class definition, and then defined later on.  This can help show what
the class does by quickly being able to read its member function prototypes.

Outside of readability, another reason for not defining functions within the
class definition is if a function definition requires knowledge of types that
are declared later in the code, or when defining templates outside the class
body.


CONSTRUCTORS
-------------------------------------------------------------------------------
Classes can optionally include a special function called its 'constructor',
which is automatically called whenever a new object of the class is created.
This allows the class to initialize member variables or allocate storage.

Constructor functions can not be explicitly called.  They are only executed once
when a new object of that class is created.

The constructor function is declared just like a regular member function, but
with a name that matches the class name and without any return type; not even
void.

Here is an example of the Rectangle class which is improved by implementing a
constructor.  In the example, the enum class is used to pass in the unit
type to use to measure the height and width.  We also introduce the 'this'
pointer which helps readability for the constructor.  Without the this pointer,
we would have had to rename the 'unit' parameter to something other than the
corresponding member identifier, essentially forcing us to come up with two
names for the same thing.

    #include <iostream>
    #include <string>

    enum class Unit { cm, in, ft };

    class Rectangle {
        int width, height;
        Unit unit;

      public:
        Rectangle(int, int, Unit);
        int getArea() {
            return width * height;
        }
        void printArea();
    };

    // javascript style syntax of defining constructors
    // other methods which are closer to cpp conventions
    // will be shown in later sections (member initialization list)
    Rectangle::Rectangle(int width, int height, Unit unit) {
        this->width = width;
        this->height = height;
        this->unit = unit;
    }

    void Rectangle::printArea() {
        std::string unitString;
        if (unit == Unit::cm) {
            unitString = "centimeters";
        } else if (unit == Unit::in) {
            unitString = "inches";
        } else if (unit == Unit::ft) {
            unitString = "feet";
        }

        std::cout << "Area: " << getArea() << " " << unitString << '\n';
    }

    int main() {
        Rectangle rect1(3, 4, Unit::in);
        Rectangle rect2(5, 6, Unit::cm);
        rect1.printArea(); // Area: 12 inches
        rect2.printArea(); // Area: 30 centimeters

        return 0;
    }


OVERLOADING CONSTRUCTORS
-------------------------------------------------------------------------------
Like any other function, a constructor can also be overloaded with different
versions taking different parameters; a different number of parameters and/or
parameters of different types.  The compiler will automatically call the one
whose parameters match the arguments.

A default constructor is a constructor that takes no arguments.  When a default
constructor is used, it is not called with an empty set of parentheses.

    #include <iostream>

    class Rectangle {
        int width, height;

      public:
        // empty arguments in constructor OR lack of a constructor means
        // that when you initialize a new Rectangle type, you do not
        // use parentheses.  The constructor below has a special name.
        // It is called the default constructor
        Rectangle();

        // arguments provided in constructor function means you DO pass
        // parentheses when initialize a new Rectangle type and you pass
        // in the arguments
        Rectangle(int, int);

        // NOTE: passing void as a parameter is simply a way to
        // state that the function takes no arguments.  It is unneccessary,
        // but not incorrect
        int getArea(void) {
            return width * height;
        }
    };

    Rectangle::Rectangle() {
        width = 5;
        height = 5;
    }

    Rectangle::Rectangle(int width, int height) {
        this->width = width;
        this->height = height;
    }

    int main() {
        Rectangle rect1(3, 4);
        Rectangle rect2;

        std::cout << "rect1 area: " << rect1.getArea() << '\n';
        std::cout << "rect2 area: " << rect2.getArea() << '\n';

        return 0;
    }


UNIFORM INITIALIZATION
-------------------------------------------------------------------------------
The way of calling constructors by enclosing their arguments in parentheses, as
shown above, is known as functional form.  Constructors can also be called with
other syntaxes.

Constructors with a single parameter can be called using the variable
initialization syntax

    ClassName objectName = initializationValue;

More recently, cpp has introduced the possibility of constructors to be called
using uniform initialization, which essentially is the same thing as function
form, but uses braces instead of parentheses.


    ClassName objectName { value, value, value, };

                    OR

    ClassName objectName = { value, value, value, };

Here is an example showing four different ways to construct objects of a class
whose constructor takes a single parameter:

    class Circle {
        double radius;

      public:
        Circle(double radius) {
            this->radius = radius;
        }
        double circumference() {
            return 2 * radius * 3.14159265;
        }
    };

    int main() {

        Circle foo(10.0);    // functional form
        Circle bar = 20.0;   // assignment initialization
        Circle baz{30.0};    // uniform initialization
        Circle qux = {40.0}; // POD-like

        return 0;
    }

An advantage of uniform intialization over functional form is that, unlike
parentheses, braces cannot be confused with function declarations, and thus
cannot be used to explicitly call default constructors.  Imagine in the example
below that Rectangle has a default constructor:

    Rectangle rect1; // default constructor called
    Rectangle rect2(); // function declaration (default constructor NOT called)
    Rectangle rect3{}; // default constructor called


MEMBER INITIALIZATION IN CONSTRUCTORS (MEMBER INITIALIZATION LIST)
-------------------------------------------------------------------------------
When a constructor is used to initialize other members, these other members can
be initialized directly without resorting to statements in its body.  This is
done by inserting, before the constructor's body, a colon (:) and a list of
initializations for class members.

    #include <iostream>

    class Rectangle {
        int width, height;

      public:
        Rectangle(int, int);
        int getArea() {
            return width * height;
        }
    };

    // The constructor for this class could be defined as usual
    // Rectangle::Rectangle(int x, int y) {
    //     width = x;
    //     height = y;
    // }
    //
    // or it could be defined using member initialization:
    Rectangle::Rectangle(int x, int y) : width(x), height(y) {
    }

    // or it could even be defined using member initialization
    // like this:
    // Rectangle::Rectangle(int x, int y) : width(x) {height = y;}

    int main() {
        Rectangle rect1(5, 10);
        std::cout << rect1.getArea() << '\n'; // 50

        return 0;
    }

Notice how in the case which is not commented out, the constructor does nothing
else besides initialize its members, thus why it has an empty function body.

For members of fundamental types, it makes no difference which of the above ways
are used to to define the constructor, because they are not initialized by
default.  However, for member objects (those whose type is a class), if they are
not initialized with member initializer list syntax, they are default
constructed.

Default constructing all members of a class may or may not always be convenient.
In some cases, this is a waste (when the member is then reinitialized otherwise
in the constructor), but in other cases, default construction is not even
possible (when the class does not have a default constructor).  In these cases,
members shall be initialized in the member initialization list.

    #include <iostream>

    class Circle {
        double radius;

      public:
        Circle(double r) : radius(r) {
        }
        double area() {
            return radius * radius * 3.14159265;
        }
    };

    class Cylinder {
        Circle base;
        double height;

      public:
        // Notice how Cylinder does not have a radius (r) member?
        // We are including the parameter r so that the Circle
        // class can be constructed.  The only way to do this is with
        // the 'member initializer list'
        Cylinder(double r, double h) : base(r), height(h) {
        }
        // the above could also use uniform initalizer syntax
        // by using braces instead of parentheses
        // Cylinder(double r, double h) : base{h}, height{h} {}

        // this is illegal.  You must the member initializer list to construct
        // Circle
        // Cylinder(double r, double h) :
        //     height(h) {
        //     Circle newBase(r);
        //     base = newBase;
        // }

        double volume() {
            return base.area() * height;
        }
    };

    int main() {

        Cylinder foo(10, 20);
        std::cout << "foo's volume: " << foo.volume() << '\n';

        return 0;
    }

It is important to note that to initialize an object that is an object of
another class (like 'Circle base' in the 'Cylinder') class, you MUST use the
member initializer list (unless the object you that is a member of the class you
are initializing has a default constructor, in which case you can simply not
include it in the constructor).

The constructor in the example above could also be written like this.  This
might be helpful to separate members that are objects of another class and can't
be default constructed, and direct members of the parent class being
constructed.

    Cylinder(double r, double h) : base{r} {
        height = h;
    }

While the hybrid aporach of mixing the initializer list with assignments in the
constructor's body is possible, it is more conventional to initialize all
members in the initializer list.  Initializing members in the initializer list
is generally more effecient and idiomatic in cpp.


POINTERS TO CLASSES
-------------------------------------------------------------------------------
Objects can also be pointed to by pointers.  Once declared, a class becomes a
valid type, so it can be used as the type pointed to by a pointer.

    Rectangle *pRect; // pointer to an object of class Rectangle

Just as with plain data structs, the members of an object be accessed directly
from a pointer by using the arrow operator -> .
    #include <iostream>

    class Rectangle {
        int width, height;

      public:
        Rectangle() {
            width = 0;
            height = 0;
        }
        Rectangle(int x, int y) :
            width(x),
            height(y) {
        }

        int getArea();
    };

    int Rectangle::getArea() {
        return width * height;
    }

    int main() {

        // instantiate a Rectangle rect
        Rectangle rect(3, 4);

        // define 3 Rectangle pointers
        Rectangle *foo, *bar, *baz;

        // point the foo pointer to the address of rect
        foo = &rect;

        // dynamically allocate memory for a new Rectangle object and
        // assign to the bar pointer
        bar = new Rectangle{5, 6};

        // dynamically allocate space for two Rectangle objects in
        // an array and assign to the baz pointer.  Since we are
        // defining the new array, we can pass the constructor
        // parameters into each cell in the new array
        baz = new Rectangle[2]{{2, 5}, {3, 6}};

        // More on the above syntax of defining a new Rectangle array
        // Since an array is a contiguous sequence of elements, if we
        // were to instantiate another rectangle outside of the statement
        // where we create the baz array pointer, and then try to
        // insert it into the array: baz[0] = rect2;  This would be
        // valid.  However, it would not 'move' the rect2 object into
        // the baz[0] block.  It would actually copy it, which is
        // not ideal.  Doing the above would look like this:

        // you NEED a default constructor for this commented out example,
        // otherwise the array can't be default initialized with
        // valid Rectangle objects
        // baz = new Rectangle[2];
        // Rectangle rect2(2, 5);
        // Rectangle rect3(3, 6);
        // baz[0] = rect2;
        // baz[1] = rect3;

        std::cout << "rect's area: " << rect.getArea() << '\n';
        std::cout << "*foo's area: " << foo->getArea() << '\n';
        std::cout << "*bar's area: " << bar->getArea() << '\n';
        std::cout << "baz[0]'s area: " << baz[0].getArea() << '\n';
        std::cout << "baz[1]'s area: " << baz[1].getArea() << '\n';

        // deallocate (free) the memory blocks that bar and baz point to
        delete bar;
        delete[] baz;

        return 0;
    }


CLASSES DEFINED WITH STRUCT AND UNION
-------------------------------------------------------------------------------
Classes can also be defined with the struct and union keywords, not just the
class keyword.

While struct is generally used to declare plain data structures, it can also be
used to declare classes that have member functions.  Classes declared with
'struct' have public access by default, whereas classes declared with 'class'
have private access by default.

Unions can also hold member functions.  As with structs, classes declared with
'union' have public access by default.


-------------------------------------------------------------------------------
CLASSES II
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/templates/
-------------------------------------------------------------------------------

OVERLOADING OPERATORS
-------------------------------------------------------------------------------
Classes, essentially, define new types to be used in cpp code.  Classes can
also interact with operators just like any type.

Take this an example using a struct.  You can in fact apply the addition
operator on the type 'MyClass'.  It would however cause a compilation error,
because the 'MyClass' type has no defined behavior for additions.

    struct MyClass {
        std::string product;
        float price;
    } a, b, c;
    a = b + c;

Cpp allows most operators to be overloaded so that their behavior can be defined
for just about any type, including those created by user defined classes.

Operators are overloaded by means of operator functions, which are just regular
functions with special names:

    return_type operator operator_sign (parameters) {
        // statements
    }

Here is an example of using the overloading the addition operator to be able to
perform an addition operation on two objects of the type Cartesian which is
defined below.  The addition operation in this use case adds up the x and y
values of two respective classes and returns a Cartesian object with the added
values.  (1, 2) + (2, 3) = (3, 5);

    #include <iostream>

    class Cartesian {
      public:
        int x, y;

        // default constructor
        Cartesian() {
            x = 0;
            y = 0;
        }

        // constructor
        Cartesian(int x, int y) :
            x(x),
            y(y) {
        }

        // FUNCTION PROTOTYPE FOR THE OVERLOADED ADDITION OPERATOR
        // return type is Cartesian
        // operator is the addition operator (+)
        // parameter is a const reference to a Cartesian object
        // the passed in parameter is a read only reference

        Cartesian operator+(const Cartesian &);

        // NOTE: we didn't give the parameter a name because
        // we don't need to.  We COULD, but since this is a
        // prototype, we only need the 'type' of the parameter.
        // It is considered best practice to include a parameter
        // name in a prototype, but I'm excluding it because it
        // will remind me that you don't need to
    };

    // DEFINE THE OVERLOADED ADDITION OPERATOR FUNCTION
    Cartesian Cartesian::operator+(const Cartesian &cartesian) {

        // create a new Cartesian object called product
        // this is what will be returned, as it will be the
        // product of the LHS and the RHS of the + operator

        Cartesian result;

        // set the x member of 'result' to the result
        // of adding the LHS and RHS Cartesian's x values
        // The LHS is the Cartesian object calling the overloaded
        // operator function

        result.x = x + cartesian.x;

        // set the y member of 'result' to the result
        // of adding the LHS and RHS Cartesian's y values

        result.y = y + cartesian.y;
        return result;
    }

    int main() {
        Cartesian foo(3, 1);
        Cartesian bar(1, 2);

        // Cartesian result = foo + bar;

        // this is more complicated than the commented out
        // way of writing it above, but it also abstracts less
        // of the process.  foo calls its 'operator+' method
        // which takes foo's x and y and adds it with passed in
        // argument bar's x and y, and applies this result of x and y
        // to an entirely new Cartesian object which gets returned
        Cartesian result = foo.operator+(bar);

        // It is preferred for readability to use the
        // 'Cartesian result = foo + bar;' syntax, but for the
        // purposes of a tutorial the uncommented out version
        // better explains the process

        std::cout << result.x << ',' << result.y << '\n'; // 4,3

        return 0;
    }

-------------------------------------------------------------------------------

    // The example above overloaded operator+ in a member function, but
    // you could also achieve the same result with a non member function
    // Here is an example:

    #include <iostream>

    class Cartesian {
      public:
        int x, y;

        // default constructor
        Cartesian() {
            x = 0;
            y = 0;
        }

        Cartesian(int x, int y) :
            x(x),
            y(y){

            };
    };

    Cartesian operator+(const Cartesian &lhs, const Cartesian &rhs) {
        Cartesian product;
        product.x = lhs.x + rhs.x;
        product.y = lhs.y + rhs.y;
        return product;
    }

    int main() {
        Cartesian foo(3, 1);
        Cartesian bar(1, 2);

        Cartesian result = foo + bar;

        // could also be written as
        // Cartesian result = operator+(foo, bar);

        std::cout << result.x << ',' << result.y << '\n';

        return 0;
    }

In the above examples, overloading the + operator strongly aligned to the
mathematical meaning of addition.  However, there is no requirement that
operator overloads do this.  We could have overloaded the + operator but
performed a mathematical subtraction operation and it would have been perfectly
valid, although strongly discouraged for how confusing that would make the code.

The parameter expected for a member function to overload for operations such as
operator+ is naturally the operand to the RHS (right hand side), but operators
can come in diverse forms and therefore it does not need to be done this way.

(https://cplusplus.com/doc/tutorial/templates/)
The above link gives a table which shows which operators can be overloaded, the
syntax, and if they can be overloaded with a non-member function or both
non-member and member functions.


THE KEYWORD THIS
-------------------------------------------------------------------------------
The keyword this, represents a pointer to the object whose member function is
being executed.  It is used within a class's member function to refer to the
object itself.

    #include <iostream>

    class Brah {
      public:
        bool isItMe(Brah &brah);
    };

    // brah is passed as a reference
    bool Brah::isItMe(Brah &brah) {

        // if address of brah == this
        if (&brah == this) {
            return true;
        } else {
            return false;
        }
    }

    int main() {
        Brah a;

        Brah *b = &a;

        // if a.isItMe(a) returns true
        if (b->isItMe(a)) {
            std::cout << "yes it is me brah"
                      << "\n\n";
        }

        std::cout << "a address: " << &a << '\n';
        std::cout << "b is a pointer to a..." << '\n' << "b address: " << b << '\n';

        return 0;
    }

'this' is also used frequently in member functions with the operator= (operator
overload).  Following the examples of the Cartesian object, we could have used
an operator= member function:

    #include <iostream>

    class Cartesian {
      public:
        int x, y;

        // default constructor
        Cartesian() {
            x = 0;
            y = 0;
        }

        // constructor
        Cartesian(int x, int y) :
            x(x),
            y(y) {
        }

        Cartesian &operator=(const Cartesian &otherCartesian);
    };

    // 'Cartesian &' means the return type is a 'reference to a Cartesian
    // object'.  This means that while it returns '*this', which is
    // the actual Cartesian object, it returns it as a reference.  This
    // also allows for assignment chaining (a = b = c;).  Without the
    // & next to Cartesian it would return a copy of the Cartesian object

    Cartesian &Cartesian::operator=(const Cartesian &otherCartesian) {
        x = otherCartesian.x;
        y = otherCartesian.y;

        // include the dereference operator here because you want to
        // return the dereferenced 'this', NOT the address it points to
        return *this;
    }

    int main() {
        Cartesian foo(2, 5);
        Cartesian bar(5, 10);
        foo = bar;

        std::cout << foo.x << ',' << foo.y << '\n'; // 5,10

        return 0;
    }


STATIC MEMBERS
-------------------------------------------------------------------------------
Classes can contain static members, which can be either data or functions.

A static data member of a class is also known as a class variable, because all
the objects of that class will share the same value.  Its value is not different
from one object of this class to another.

Static members cannot be initialized directly within the class, but need to be
initialized somewhere outside of it.  This is because static members have class
scope.

    type ClassName::identifier = initialValue;

Complete syntax is shown in the example below:

    #include <iostream>

    class Brah {
      public:
        static int n;
        Brah() {
            n++;
        }
    };

    // initialize n to 0
    int Brah::n = 0;

    int main() {

        Brah brah;
        std::cout << brah.n << '\n'; // 1

        // note we can do this because Brah does not have a constructor.
        // If it had a constructor we would also need to make sure it
        // had a default constructor or else we couldn't populate the
        // array with default 'Brah's.
        Brah arrayOfBrahs[5];
        std::cout << arrayOfBrahs[3].n << '\n'; // 6

        Brah *brah2 = new Brah;
        std::cout << brah2->n << '\n'; // 7

        std::cout << Brah::n << '\n'; // 7

        delete brah2;

        return 0;
    }

In the example above, note how the static variable is common for all the class
members.  'n' could have been accessed by any of the instantiated objects during
any of the std::cout statements and the same number would have been printed out.
You can additionally refer to 'n' with the scope resolution operator (::) like
this: 'Brah::n;' which also gives you the same result.

A static variable is in essence a non member variable, but one that can only be
accessed like a member of a class.

Static member functions follow the same principles as static variables.  They
cannot access non-static member functions because they cannot use the word
'this', nor do they have a 'this'.


CONST MEMBER FUNCTIONS
-------------------------------------------------------------------------------
To qualify a member function of a class as const, use the following syntax:

    type functionName(params...) const { // body; }

When a member function is qualified as const, that function loses the ability to
modify any member variables (except for static member variables, and member
variables qualified with the mutable keyword).  It also loses the ability to
call other member functions that are not const qualified.  A const member
function which calls another member function which is not const qualified would
drop the constness of the the const member function which makes it illogical.


CONST OBJECTS
-------------------------------------------------------------------------------
To qualify an instance of a class as const, use the following syntax:

    const ClassName objectName;

Static member variables (and member variables qualified with the mutable
keyword) will still be able to be modified however, as static member variables
don't belong to any single instance. When a class object is qualified as const,
that object of the class now becomes read only.

In addition to becoming read only:
    - It will only be able to call member functions that are const qualified.
      Given this last statement, the object cannot modify member variables from
      within either because const qualified member functions cannot modify
      member variables.

    - Even though it was already stated that const qualifying a class makes it
      read only; to be clear, non-static public variables (except for those
      qualified with the mutable keyword) will not be able to be modified from
      outside the class as they would normally. They will be read only of
      course.


    class MyClass {
        int priv;

      public:
        int pub;
        MyClass(int priv, int pub) :
            priv(priv),
            pub(pub) {
        }
        void modifyPub(int newValue) {
            pub = newValue;
        }
        void modifyPriv(int newValue) {
            priv = newValue;
        }

        // qualifying a member function with const
        int getPriv() const {
            return priv;
        }
    };

    int main() {
        MyClass m(10, 20);
        std::cout << "pub: " << m.pub << " priv: " << m.getPriv() << "\n";
        // std::cout << m.priv; // invalid: priv is a private member
        std::cout << m.pub << '\n'; // okay, pub is a public member
        // okay, modify priv from inside the class
        m.modifyPriv(25);
        // okay
        m.modifyPub(50);

        // while m is not const qualified, it can still call
        // const qualified member functions as shown here where
        // it calls getPriv() which is a const member function
        std::cout << "pub: " << m.pub << " priv: " << m.getPriv() << "\n";

        std::cout << "\nconst qualified class\n--------------------\n";
        const MyClass c(10, 20);
        // std::cout << c.priv << '\n'; // invalid: private is a private member
        std::cout << c.pub << '\n'; // okay, pub is a public member

        // both of these are invalid.
        // because c is qualified as const, the member functions would
        // have needed to be defined as const
        // and even if these function were...they would still be invalid
        // because const functions cannot modify the class state!
        // c.modifyPriv(25);
        // c.modifyPub(50);


CONST RETURN TYPES
-------------------------------------------------------------------------------
const can also be used to qualify the type returned by a member function.  Just
because a function returns a const qualified type, does not mean that the
function itself becomes a const function.

Here is a demonstration of the syntax and common use cases.  It specifies that
the member function will return a const reference to what it returns. Rather
than return a copy which could be costly, especially with compound data types,
it returns a 'read only' reference to whatever it is returning:

    // member function returning const int reference
    const int& get() { return x; }

    // const member function returning const int reference
    const int & get() const { return x; }

    // const member function
    int get() const { return x; }

However, it is important to note that if a reference is returned by a function,
it will still be copied if the variable it is returned to is not declared as a
reference.  If the variable it is returned to IS a reference, then the value
returned WILL be passed by reference.

Here is an example demonstrating how the above concepts might be used:

    class MyClass {
        int x;

      public:
        MyClass(int x) :
            x{x} {
        }

        // this const qualified member function
        // returns a const qualified reference to
        // the member variable x
        const int &get() const {
            return x;
        }
    };

    // if we didn't make the the member function
    // 'get' const qualified, we wouldn't be able to call it
    // from 'print' given that const objects can only call
    // const qualified member functions
    void print(const MyClass &myClass) {
        std::cout << myClass.get() << '\n';
    }

    int main() {
        MyClass myClass(5);
        print(myClass);

        return 0;
    }


OVERLOADING MEMBER FUNCTIONS ON CONSTNESS
-------------------------------------------------------------------------------
A class may have two member functions with identical signatures, except that one
is const and the other is not.  In this case, the const version is called only
when the object itself is const qualified, and the non-const version is called
when the object itself is NOT const qualified.

Here is an example which shows both overloading member functions on constness,
but also an evolution of the section above on const return types and const
reference return types:

    class MyClass {
        int x;

      public:
        MyClass(int x) :
            x{x} {
        }

        // (called when the instance is const qualified)
        // this const qualified member function
        // returns a const qualified reference to
        // the member variable x
        const int &get() const {
            return x;
        }

        // (called when the instance is NOT const qualified)
        // return a non-const reference to x which
        // allows x to now be modified from wherever
        // x gets returned to
        int &get() {
            return x;
        }
    };

    int main() {
        MyClass foo(10);
        int &y = foo.get();
        y = 20;
        std::cout << foo.get() << '\n'; // 20

        const MyClass bar(10);
        // the below statement throws an error because bar returns a
        // const ref to x and z being declared as a ref to x would
        // allow modification
        // int &z = bar.get();

        // doesn't throw an error because z is a copy of x.  z cannot
        // modify the value of x
        int z = bar.get();
        z = 20;
        std::cout << bar.get() << '\n'; // 10

        return 0;
    }


CLASS TEMPLATES
-------------------------------------------------------------------------------
Just like we can create function templates, we can also create class templates,
which allow classes to have members that use template parameters as types.  As
with function templates, the 'typename' and 'classname' keywords can both be
used interchangeably.

In the example below, note how the template needs to be redefined as when
defining a member function outside of the scope of the class definition.

    template <typename T> class MyPair {
        T values[2];

      public:
        MyPair(T first, T second) {
            values[0] = first;
            values[1] = second;
        }
        T *getValues() {
            return values;
        }
        // member function prototype
        T getMax();
    };

    // In the case a member function is defined outside of
    // class template scope, the template needs to be
    // redefined again
    template <typename T> T MyPair<T>::getMax() {
        T max = values[0];
        for (int i = 1; i < 2; i++) {
            if (values[i] > max)
                max = values[i];
        }
        return max;
    }

    int main() {

        MyPair<int> mp1(100, 200);
        MyPair<double> mp2(4.2342, 5.234);

        // creating pointers to access the private values array in
        // order to print the values is completely unnecessary (and
        // bad practice access private data outside of the class)
        // and I could have just created a member function to print
        // the values, but I wanted practice with pointers
        int *p1 = mp1.getValues();
        double *p2 = mp2.getValues();

        for (int i = 0; i < 2; i++) {
            std::cout << p1[i] << '\n';
            std::cout << p2[i] << '\n';
        }

        std::cout << "\nmax values: \n";
        std::cout << mp1.getMax() << '\n'; // 200
        std::cout << mp2.getMax() << '\n'; // 5.234

        return 0;
    }


CLASS TEMPLATE SPECIALIZATION
-------------------------------------------------------------------------------
It is possible to define a different implementation for a class when a specific
type is passed as a template argument.  This is called template specialization.

To explain this, so we have very simple class called MyValue which can store one
element on any type and it contains only one member function called increase,
which increases its value.  We may want to have a different member function in
place of increase if we pass a char into the template argument.

Just as with function templates and class templates, class template
specialization allows you to use the keywords 'classname' and 'typename'
interchangeably.

The syntax is as follows:

    template <> typename ClassName <type> { ... };

Here is an example in code:

    #include <iostream>

    template <typename T> class MyValue {
        T element;

      public:
        MyValue(T value) :
            element(value) {
        }

        T increase() {
            return ++element;
        }
    };

    // class template specialization
    template <> class MyValue<char> {
        char element;

      public:
        MyValue(char value) :
            element(value) {
        }

        char toUpperCase() {

            // this relies on the fact that ASCII letters
            // are sequentially ordered
            if (element >= 'a' && element <= 'z') {
                // increase char index by 'A' indexes,
                // then decrease char index by 'a' indexes
                // which effectively capitalizes a char in the
                // range of 'a' - 'z'
                element += 'A' - 'a';
            }
            return element;
        }
    };

    int main() {
        MyValue<int> myInt(5);
        MyValue<char> myChar('j');
        std::cout << myInt.increase() << '\n';
        std::cout << myChar.toUpperCase() << '\n';

        return 0;
    }

When declaring specializations for a template class, we must also define all its
members, even members identical to the generic template class.  There is no
'inheritance' of members from the generic template to the specialization.


-------------------------------------------------------------------------------
SPECIAL MEMBERS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/classes2/
-------------------------------------------------------------------------------
Special member functions are member functions that are implicitly defined as
members of classes under certain circumstances.  There are six special member
functions:

    default constructor |  ClassName::ClassName()
                        |
    destructor          |  ClassName::~ClassName()
                        |
    copy constructor    |  ClassName::ClassName(const ClassName&)
                        |
    copy assignment     |  ClassName& operator= (const ClassName&)
                        |
    move constructor    |  ClassName::ClassName(ClassName&&)
                        |
    move assignment     |  ClassName& operator= (ClassName&&)


DEFAULT CONSTRUCTOR
-------------------------------------------------------------------------------
The default constructor is the constructor called when objects of a class are
declared, but not initialized with any arguments.

If a class definition has no constructors, then the compiler assumes the class
to have an implicitly defined constructor and the class can be declared like
this:

    Example ex;

But as soon as a class has any constructor explicitly declared (taking any
number of arguments), the compiler will no longer automatically provide and
implicit default constructor.  If there are explictly defined constructors and
not one of them is a default constructor, then new objects will not be able to
be created without passing in argument(s). A default constructor is a
constructor which has no parameters or a constructor which has all optional
parameters.

    class Example2 {
      public:
        int total;
        // explicitly defined constructor
        Example2(int initialValue) :
            total(initialValue) {
        }
    }

    Example2 ex(100); // ok: calls constructor
    Example2 ex; // invalid: no default constructor


DESTRUCTOR
-------------------------------------------------------------------------------
Destructors fulfill the opposite functionality of constructors.  They are
responsible for the necessary cleanup needed by a class when its lifetime ends.
This is useful for classes which allocate dynamic memory during their lifetime.

    #include <iostream>
    #include <string>

    class Example {
        // declare std::string pointer p
        std::string *p;

      public:
        // default constructor
        Example() :
            // using member initialization list which makes
            // this line read as:
            // the std::string pointer p is equal to new std::string;
            p(new std::string) {
        }

        // constructor (not default)
        // takes in a const reference to a std::string
        Example(const std::string &str) :
            // yes, std::string can take an argument to
            // initilize
            // the std::string pointer p is equal to new std::string(str)
            p(new std::string(str)) {
        }

        // destructor
        ~Example() {
            delete p;
        }

        // access content
        // const reference return type / const member function
        const std::string &content() const {
            // return the value of where p points to
            // by utilizing the dereference operator
            return *p;
        }
        // remember, if the const reference is not returned
        // into a variable which is defined as a reference it will
        // be otherwise copied into the variable, rather than
        // passed as a reference
    };

    int main() {
        Example foo;
        Example bar("Brah");

        std::cout << "bar's content: " << bar.content() << '\n';

        return 0;
    }

In the above example the destructor is called at the end of the main() function.

For statically or automatically created objects, the destructor would be called
when the object goes out of scope.  Although foo and bar had member variables
which were dynamically allocated, the objects themselves were automatically
created because they were not assigned to a pointer with new, and thus, their
destructor is called at the end of main() because this is the end of their
scope.

For dynamically created objects, the destructor is called automatically when the
object is deallocated from the heap with the delete or delete[].  C-style memory
management functions (malloc, calloc, realloc, free) won't invoke the destructor
because destructors are not a part of the C language.


COPY CONSTRUCTOR
-------------------------------------------------------------------------------
When an object is passed a named object of its own type as an argument, it's
copy constructor is invoked in order to construct a copy.

A copy constructor is a constructor whose first parameter is of type "reference
to the class itself", and which can be invoked with a single argument of this
type.  It is probably good practice to make the reference to the object const
qualified to avoid accidental modification (unless modification is desired)

    MyClass::MyClass(const MyClass &myClass) { ... }

If the class has no custom copy or custom move constructors defined, an implicit
copy constructor is provided which performs a shallow copy:

    // an implicit copy constructor performs a shallow copy
    // which is roughly equivalent to this
    MyClass::MyClass(const MyClass &x) :
        a(x.a),
        b(x.b),
        c(x.c) {}

The implicit / default copy constructor may suit the needs of many classes.
However 'shallow copies' only copy the members of the class themselves, and in
the case of the Example class that demonstrated the 'destructor' special member
function, this would probably not be ideal because the Example class used a
pointer to a std::string as its only member variable.  If we were to 'shallow
copy' the Example class we would only be copying the pointer, and thus the 'p'
member variable in both classes would point to the same location in memory,
effectively sharing the same std::string object.  To make matters worse, at some
point, on destruction, both objects would try to delete the same block of
memory, which could cause the program to crash on runtime.  The issues described
above can be solved by defining a custom copy constructor that performs a deep
copy instead of a shallow copy.  Therefore, defining a copy constructor is very
relevant to objects which contain member variables that are pointers.

    class Example {
        // declare std::string pointer p
        std::string *p;

      public:
        // default constructor
        Example() :
            p(new std::string) {
        }

        // constructor (not default)
        Example(const std::string &str) :
            p(new std::string(str)) {
        }

        // destructor
        ~Example() {
            delete p;
        }

        // copy contructor
        Example(const Example &example) :

            // ironically we are using the std::string copy constructor to
            // perform this
            p(new std::string(example.content())) {
        }

        const std::string &content() const {
            return *p;
        }
    };

    int main() {
        Example foo("dawg");
        Example bar(foo);

        std::cout << "bar's content: " << bar.content() << '\n';

        return 0;
    }

The example above performs a 'deep copy' in its explicitly defined copy
constructor.  It allocates storage for a new std::string variable which is
initialized to contain a copy of the original object's std::string variable.


COPY ASSIGNMENT
-------------------------------------------------------------------------------
While objects can be copied when they are initialized as shown with the copy
constructor above, they can also be copied on any assignment operation.

    // default constructor called
    MyClass foo;

    // object initialization, copy constructor called
    MyClass bar(foo);

    // object initilization, copy contructor called
    // object is initialized with variable initialization syntax because
    // an object constructor with only a single parameter can be called
    // with variable initialization syntax
    MyClass baz = foo;

    // object already initialized, copy ASSIGNMENT called
    foo = bar; // object already initialized, copy ASSIGNMENT called

The copy assignment is an overload of operator= which takes a value or reference
of the class itself as a parameter.  The return value is generally a reference
to *this (but not required).  The copy assignment may have the following
signature:

    MyClass& operator=(const MyClass&);

The copy assignment operator is also defined implicitly if a class has no custom
copy nor move assignments (nor move constructors) defined.  The same way the
implicit version of the copy constructor performs a 'shallow copy', the implicit
copy assignment operator also performs a shallow copy, which makes the implicit
copy assignment operator unsuitable for classes with pointers to objects that
handle dynamic memory.  By performing a shallow copy, the class incurs the risk
of deleting the pointed object twice, but the assignment creates memory leaks by
not deleting the object pointed by the object before assignment.  These issues
can be solved with a copy assignment that deletes the previous object and
performs a deep copy.

    #include <iostream>
    #include <string>

    class Example {
        // declare std::string pointer p
        std::string *p;

      public:
        // default constructor
        Example() :
            p(new std::string) {
        }

        // constructor (not default)
        Example(const std::string &str) :
            p(new std::string(str)) {
        }

        // destructor
        ~Example() {
            delete p;
        }

        // copy contructor
        Example(const Example &example) :
            // example.content() returns the value
            // of its p pointer to the initializer of the
            // string class and assigns the new string
            // to this classes pointer 'p'
            p(new std::string(example.content())) {
        }

        // copy assignment operator
        // Example & means the return type is a 'reference' to an
        // Example object.  This means it returns *this, which is
        // an actual Example object (not the location in memory), it
        // returns it as a reference

        Example &operator=(const Example &example) {

            // deallocate the memory block where p
            // points to, but not delete the p pointer itself
            delete p;

            p = new std::string(example.content());

            // return the dereferenced this, which essentially
            // means: return the value of this object as a whole,
            // NOT its memory address.

            return *this;
        }


        const std::string &content() const {
            return *p;
        }
    };

    int main() {
        Example foo("dawg");
        Example bar("bro");

        bar = foo;

        // does the same thing as bar = foo
        // bar.operator=(foo);

        std::cout << "bar's content: " << bar.content() << '\n'; // dawg

        return 0;
    }

In the above example, we could also rewrite the copy assignment operator special
function like this because the p member variable is not a constant, nor is it a
reference.

    // copy assignment operator (special function)
    // Example & means the return type is a 'reference' to an
    // Example object.  This means it returns *this, which is
    // an actual Example object (not the location in memory), it
    // returns it as a reference

    Example &operator=(const Example &example) {

        // the value p points to equals the std::string that
        // example.content() returns
        // even though example.content() returns a const
        // reference to a std::string object, *p is not a
        // reference, so the value will be copied into
        // the location p points to....and if you were to remove
        // the *, remember that example.content() does NOT return
        // the address of, it returns a reference...two different
        // things.
        *p = example.content();

        // return the dereferenced this, which essentially
        // means: return the value of this object as a whole,
        // NOT its memory address.
        return *this;
    }


MOVE CONSTRUCTOR AND ASSIGNMENT
-------------------------------------------------------------------------------
Similar to the copy counterparts, moving also uses the value of an object to set
the value of another object.  A major difference is that moving transfers one
object (the source) to another (the destination), and the source loses that
content which is taken over by the destination.  This moving only happens when
the source of the value is an UNNAMED OBJECT.

Unnamed objects are objects that are temporary in nature, thus haven't even been
given a name.  Some typical values of unnamed objects are return values of
functions or type-casts.


The move contructor and move assignment are special member functions which take
a parameter of type 'rvalue reference to the class itself':

    MyClass(MyClass &&); // move constructor
    MyClass& operator=(MyClass &&); // move assignment

rvalues cannot normally be assigned to a reference type.  The two && creates an
rvalue reference type which allows this.

The concept of moving is most useful for objects which allocate storage with new
and delete.

Remember that cpp allows you to abstract away some of the logic when you call
operator overloads by allowing you to write the syntax as if it were any normal
expression.  It may be helpful to go back and revisit operator overloads if the
example below is confusing at all.

    class Example {
        std::string *ptr;

      public:
        Example(const std::string &str) :
            ptr(new std::string(str)) {
        }

        ~Example() {
            delete ptr;
        }

        // move constructor
        Example(Example &&x) :
            ptr(x.ptr) {
            x.ptr = nullptr;
        }

        // move assignment
        Example &operator=(Example &&x) {
            delete ptr;
            ptr = x.ptr;
            x.ptr = nullptr;
            return *this;
        }

        // access content
        const std::string &content() const {
            return *ptr;
        }

        // addition operator overload
        // returns a rvalue of type Example which is then used in the
        // move assignment which uses an rvalue reference as a parameter
        Example operator+(const Example &rhs) {
            return Example(content() + rhs.content());
        }
    };

    int main() {
        Example foo("Hello ");
        Example bar = Example("Brah"); // move-construction

        foo = foo + bar; // move assignment

        std::cout << foo.content() << '\n';

        return 0;
    }


Compilers already optimize many cases that formally require a move-construction
call in what is known as RETURN VALUE OPTIMIZATION.  Most notably, when the
value returned by a function is used to initialize an object.  In these cases,
the move constructor may actually never get called.

NOTE:  Even though rvalue references can be used for the type of any function
parameter, it is seldom useful for uses other than the move constructor.  Rvalue
references are tricky, and unnecessary uses may be the source of errors quite
difficult to track.


IMPLICIT MEMBERS
-------------------------------------------------------------------------------
The six special members functions described above are members implicitly
declared on classes under certain circumstances.

    MEMBER FUNCTION     | IMPLICITLY DEFINED       | DEFAULT DEFINITION
    --------------------------------------------------------------------
    Default Constructor | if no other constructors | does nothing
    --------------------------------------------------------------------
    Destructor          | if no destructor         | does nothing
    --------------------------------------------------------------------
    Copy Constructor    | if no move constructor,  | copies all members
                        | and no move assignment   |
    --------------------------------------------------------------------
    Copy Assignment     | if no move constructor,  | copies all members
                        | and no move assignment   |
    --------------------------------------------------------------------
    Move Constructor    | if no destructor, copy   | moves all members
                        | constructor, no copy nor |
                        | move assignments         |
    --------------------------------------------------------------------
    Move Assignment     | if no destructor, copy   | moves all members
                        | constructor, no copy nor |
                        | move assignments         |
    --------------------------------------------------------------------


DEFAULT AND DELETE KEYWORDS
-------------------------------------------------------------------------------
All classes can explicitly select which of the special member functions are
included or excluded in their default definition with the keywords DEFAULT and
DELETE.

    class Rectangle {
        int width, height;

      public:
        Rectangle(int x, int y) :
            width(x),
            height(y) {
        }

        // explicitly state that the 'default' default constructor
        // will be used
        Rectangle() = default;

        // this class can no longer use the copy constructor
        // this deletes the implicitly defined copy constructor
        Rectangle(const Rectangle &other) = delete;

        int area() {
            return width * height;
        }
    };

    int main() {
        Rectangle foo;
        Rectangle bar(10, 20);

        return 0;
    }


NOTE: 'default' in this case refers to the constructor which is implicitly defined
if not deleted, NOT the default-constructor itself;


Classes which explicitly defined one copy/move constructor or one copy/move
assignment but not both are encouraged to specify either delete or default on
the other special member functions they don't explicitly define. (could use a
more thorough explanation on this)


-------------------------------------------------------------------------------
FRIENDSHIP AND INHERITANCE
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/inheritance/
-------------------------------------------------------------------------------
In principle, private and protected members of a class cannot be accessed
fromoutside the same class in whcih they are declared.  However, this rule does
not apply to 'friends'.

Friends are functions or classes declared with the FRIEND keyword.  A NON-MEMBER
function can access the private and protected members of a class if it is
declared a FRIEND of that class.  This is done by including a declaration of
this external function within the class and preceding it with the keyword
friend.

    class Rectangle {
        int width, height;

      public:
        Rectangle() {
        }

        Rectangle(int width, int height) :
            width(width),
            height(height) {
        }

        int getArea() {
            return width * height;
        }

        friend Rectangle duplicate(const Rectangle &rectangle);
    };

    // Normally this function wouldn't be able to access the private
    // member variables height and width from a Rectangle object,
    // but since the Rectangle class declared it as a friend within
    // the class defintion, it is allowed

    Rectangle duplicate(const Rectangle &rectangle) {
        Rectangle result;
        result.width = rectangle.width * 2;
        result.height = rectangle.height * 2;
        return result;
    }

    int main() {
        Rectangle foo;
        Rectangle bar(2, 3);
        foo = duplicate(bar);
        std::cout << foo.getArea() << '\n'; // 24

        return 0;
    }

NOTE: You could also define the friend function entirely within the Rectangle
class definition as well.  Either way, the duplicate function is NOT considered
a member of the Rectangle class.  It can simply access its private and protected
members without being a member itself.

Typical use cases of friend functions are operations that are conducted between
two different classes accessing private or protected members, or both.


FRIEND CLASSES
-------------------------------------------------------------------------------
A friend class is a class whose members have access to the private or protected
members of another class.

    class Square;

    class Rectangle {
        int width, height;

      public:
        int getArea() {
            return width * height;
        }

        void convert(Square square);
    };

    class Square {
        friend class Rectangle;

      private:
        int side;

      public:
        Square(int a) :
            side(a) {
        }
    };

    // Square defines Rectangle as it's friend.  Therefore, this
    // Rectangle member function can access the private member
    // variable 'side' from the Square class
    void Rectangle::convert(Square square) {
        width = square.side;
        height = square.side;
    }

    int main() {
        Rectangle rectangle;
        Square square(10);
        rectangle.convert(square);
        std::cout << rectangle.getArea() << '\n'; // 100

        return 0;
    }

Not only does this example show the behavior of the friendship between classes,
but is also introduces the concept of an empty declaration of a class.

The Square class must be declared before the Rectangle class so that the
Rectangle class can use the Square class in its Rectangle::convert(Square
square) function declaration.  Conversely, the Square class uses the Rectangle
class by declaring it as a friend so it couldn't have been declared without an
empty declaration above the Rectangle class.

Another property of friendships is that they are not transitive.  The friend of
a friend is not considered a friend unless explicitly specified.


INHERITANCE BETWEEN CLASSES
-------------------------------------------------------------------------------
Classes in cpp can be extended, creating new classes which retain
characteristics of the base class.  This process is known as inheritance.  It
involves a BASE CLASS and a DERIVED CLASS.  The DERIVED CLASS inherits the
member of the BASE CLASS, on top of which it can add its own members.

Classes that are derived from a base class inherit all the accessible members of
the case class.  The derived class can also be defined with its own members, in
such a way that if base class includes member A, and we derive a class from it
with another member B, the derived class will have both member A and member B.

The syntax is as follows:

    class derivedClassName: public BaseClassName {
        /*...*/
    }

The public access specifier in the syntax example above may be replaced by any
one of the other access specifiers (protected or private).  This access
specifier specifies the most accessible level for the members inherited from the
base class.  (this explanation from cplusplus.com sucks)

    class Polygon {
      protected:
        int width, height;

      public:
        void setValues(int x, int y) {
            width = x;
            height = y;
        }
    };

    class Rectangle : public Polygon {
      public:
        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon {
      public:
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {
        Rectangle rectangle;
        Triangle triangle;
        rectangle.setValues(2, 2);
        triangle.setValues(5, 6);
        std::cout << rectangle.getArea() << '\n'; // 4
        std::cout << triangle.getArea() << '\n';  // 15

        return 0;
    }

In the example above, the protected access specifier used in the Polygon class
is similar to private.  The only difference occurs with inheritance.  When a
class inherits another one, the members of the derived class can access the
protected members inherited from the base class, but not the private members.
In the example above, if you were to change the protected access specifier to
private in the Polygon class, then the Rectangle and Triangle classes would not
be able to access the height and width member variables.

By declaring width and height as protected instead of private, these members are
also accessible from the derived classes, instead of just from instances of
Polygon.

    Access                    | public | protected | private
    ----------------------------------------------------------
    members of the same class | yes    | yes       | yes
    ----------------------------------------------------------
    members of derived class  | yes    | yes       | no
    ----------------------------------------------------------
    non members               | yes    | no        | no


'non members' represents any access from outside the class, such as from main,
from another class, or from a function.

In the above example, the members inherited by Rectangle and Triangle have the
same access permissions as they had in thier base class.

    Polygon::width         // protected access
    Rectangle::width       // protected access
    Polygon::setValues()   // public access
    Rectangle::setValues() // public access

This is because the inheritance relation has been declared using the public
keyword on each of the derived classes

    class Rectangle : public Polygon { /* ... */ };

public is the most accessible level a derived class could have.  The class will
inherit all the members with the same levels they had in the base class.

With 'protected', all public members of the base class are inherited as
protected in the derived class.

With 'private', all the base class members are inherited as private.

    class Daughter : protected Mother;

This would set protected as the less restrictive access level for the members of
Daughter that it inherited from Mother.  That is, all members that were public
in Mother would become protected in Daughter.  Of course, if Daughter declared
its own public members, they would still be public.

If no access level is specified for the inheritance, the compiler assumes
private for classes declared with keyword class and public for those declared
with struct.


WHAT IS INHERITED FROM THE BASE CLASS?
-------------------------------------------------------------------------------
A publicly derived class inherits access to every member of except:

    - its private members
    - its constructors and destructor
    - its assignment operator members(operator=)
    - its friends

Even though access to the constructors and destructor of the base class is not
inherited as such, they are automatically called by the constructors and destroy
of the derived class.

Unless otherwise specified, the constructors of a derived class call the default
constructor of its base classes.  Calling a different constructor of a base
class is possible.

    derivedConstructorName(parameters) : baseConstructorName(parameters) {...}

Example:

    class Mother {
      public:
        Mother() {
            std::cout << "Mother: no parameters\n";
        }

        Mother(int x) {
            std::cout << "Mother: int parameter\n";
        }
    };

    class Daughter : public Mother {
      public:
        Daughter(int x) {
            std::cout << "Daughter: int parameter\n";
        }
    };

    class Son : public Mother {
      public:
        Son(int x) :
            Mother(x) {
            std::cout << "Son: int parameter\n";
        }
    };

    int main() {
        Daughter kelly(0);
        Son buf(0);

        return 0;
    }


MULTIPLE INHERITANCE
-------------------------------------------------------------------------------
A class may inherit from more than one class by simply specifying more base
classes, separated by commas.  For example, if the program had a specific class
to print on screen called Output, and we wanted our classes Rectangle and
Triangle to also inherit its members in addition to those of Polygon:

    class Rectangle : public Polygon, public Output;
    class Triangle : public Polygon, public Output;

Here is the complete example:

    class Polygon {
      protected:
        int width, height;

      public:
        Polygon(int width, int height) :
            width(width),
            height(height) {
        }
    };

    class Output {
      public:
        static void print(int i);
    };

    void Output::print(int i) {
        std::cout << i << '\n';
    }

    class Rectangle : public Polygon, public Output {
      public:
        Rectangle(int width, int height) :
            Polygon(width, height) {
        }
        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon, public Output {
      public:
        Triangle(int width, int height) :
            Polygon(width, height) {
        }
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {
        Rectangle rectangle(4, 5);
        Triangle triangle(4, 5);

        // two separate ways of calling the static member function print
        rectangle.print(rectangle.getArea());
        Triangle::print(triangle.getArea());

        return 0;
    }


-------------------------------------------------------------------------------
POLYMORPHISM
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/polymorphism/
-------------------------------------------------------------------------------

POINTERS TO BASE CLASS
-------------------------------------------------------------------------------
A key feature of class inheritance is that a pointer to a derived class is
type-compatible with a pointer to its base class.   However, a pointer which is
of the type of the base class can only access members inherited from the base
class if it is pointed to a derived class.

    class Polygon {
      protected:
        int width, height;

      public:
        void setValues(int width, int height) {
            this->width = width;
            this->height = height;
        }
    };

    class Rectangle : public Polygon {
      public:
        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon {
      public:
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {
        Rectangle rectangle;
        Triangle triangle;
        Polygon *pPoly1 = &rectangle;
        Polygon *pPoly2 = &triangle;

        pPoly1->setValues(4, 5);
        pPoly2->setValues(4, 5);

        std::cout << rectangle.getArea() << '\n';
        std::cout << triangle.getArea() << '\n';

        // invalid because a Polygon pointer cannot access members
        // of derived classes that it did not give to them
        // std::cout << pPoly1->getArea() << '\n';

        return 0;
    }

In the above example, if the Polygon class declared a member function named
'getArea', then getArea could have been accessed.  However, the problem is that
Rectangle and Triangle both have their own different versions of 'getArea',
therefore there is not a single common version that could be implemented in the
class.  In the example above, if Polygon defined a common getArea member
function, then a Polygon pointer to a Triangle object would run the getArea
version from the Polygon class, NOT the Triangle class which is going to be an
undesired effect in most cases.


VIRTUAL MEMBERS / POLYMORPHISM
-------------------------------------------------------------------------------
A virtual member is a member function which can be redefined in a derived class,
while preserving its calling properties through references.  THe syntax for a
function to become virtual is to precede its declaration with the VIRTUAL
keyword.

A class that declares of inherits a virtual function is called a POLYMORPHIC
CLASS.

    class Polygon {
      protected:
        int width, height;

      public:
        void setValues(int width, int height) {
            this->width = width;
            this->height = height;
        }

        virtual int getArea() {
            return 0;
        }
    };

    class Rectangle : public Polygon {
      public:
        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon {
      public:
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {
        Rectangle rectangle;
        Triangle triangle;
        Polygon polygon;

        Polygon *pp1 = &rectangle;
        Polygon *pp2 = &triangle;
        Polygon *pp3 = &polygon;

        pp1->setValues(5, 10);
        pp2->setValues(5, 10);
        pp3->setValues(5, 10);

        // pointer to Rectangle object
        std::cout << pp1->getArea() << '\n'; // 50

        // pointer to Triangle object
        std::cout << pp2->getArea() << '\n'; // 25

        // pointer to Polygon object
        std::cout << pp3->getArea() << '\n'; // 0

        return 0;
    }


The virtual keyword allows the base class to access the virtual functions local
to the derived classes.  Non-virtual members can also be redefined in the
derived classes, but unlike virtual memebers, they will not be able to be
accessed through a reference of the base class.  In the above example, if
virtual were removed from the declaration of getArea in the Polygon class, all
three calls to getArea would return 0 because the base class (Polygon) version
of getArea would have been called.

A class that declares of inherits a virtual function is called a POLYMORPHIC
CLASS.


ABSTRACT BASE CLASSES  / ABSTRACTION
-------------------------------------------------------------------------------
Abstract base classes are classes that can only be used as base classes, and
thus are allowed to have virtual member functions without definition.  A virtual
member function without definition is what is known as a PURE VIRTUAL FUNCTION.
Classes which contain one or more VIRTUAL FUNCTIONS are known as ABSTRACT BASE
CLASSES.

The syntax to create a 'pure virtual function' is as follows:

    virtual int area() = 0;

'Abstract base classes' cannot be instantiated.  Therefore, a class that
contains even a single 'pure virtual function' cannot be instantiated.  While a
an abstract base class cannot instantiate objects, it can be used to create
pointers of the type of the base class:

    Polygon *pointerToDerivedClass;

Such a pointer can actually be dereferenced when pointing to objects of derived
(non-abstract) classes.

    class Polygon {
      protected:
        int width, height;

      public:
        void setValues(int width, int height) {
            this->width = width;
            this->height = height;
        }

        virtual int getArea() = 0;

        // Abstract base classes get access to a derived class's 'this'
        void printArea() {
            std::cout << this->getArea() << '\n';
    }
    };

    class Rectangle : public Polygon {
      public:
        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon {
      public:
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {
        Rectangle rectangle;
        Triangle triangle;

        Polygon *rect = &rectangle;
        Polygon *tri = &triangle;

        // still able to dereference the derived classes
        // even though Polygon is an Abstract Base Class
        rect->setValues(5, 10);
        tri->setValues(5, 10);

        rect->getArea(); // 50
        tri->getArea();  // 25

        return 0;
    }

Example using constructors rather than the setValues member function, as well as
dynamic memory:

    class Polygon {
      protected:
        int width, height;

      public:
        Polygon(int width, int height) :
            width(width),
            height(height) {
        }

        virtual int getArea() = 0;

        void printArea() {
            std::cout << this->getArea() << '\n';
        }
    };

    class Rectangle : public Polygon {
      public:
        // use the constructor from the base class
        Rectangle(int width, int height) :
            Polygon(width, height) {
        }

        int getArea() {
            return width * height;
        }
    };

    class Triangle : public Polygon {
      public:
        Triangle(int width, int height) :
            Polygon(width, height) {
        }
        int getArea() {
            return (width * height) / 2;
        }
    };

    int main() {

        Polygon *rect = new Rectangle(4, 5);
        Polygon *tri = new Triangle(4, 5);

        rect->printArea();
        tri->printArea();

        // cpp lint will throw a warning here that there is a non virtual
        // destructor, which means the destructor is implicitly created
        // because we never explicitly defined one.  The code still runs,
        // but it is best practice to define a virtual destructor for the
        // Polygon class
        delete rect;
        delete tri;

        return 0;
    }


-------------------------------------------------------------------------------
TYPE CONVERSIONS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/typecasting/
-------------------------------------------------------------------------------

IMPLICIT CONVERSION
-------------------------------------------------------------------------------
Implicit conversions are automatically performed when a value is copied to a
compatible type:

    short x = 2000;
    int y = x;

The above was able to convert short 'x' into an int without the need of any
explicit operator.  This is known as STANDARD CONVERSION.  Standard conversion
affect fundamental data types, and allow the conversions between numerical types
(short to int, int to float, double to int....), to or from bool, and some
pointer conversions.

The above is also an example of PROMOTION, which means converting a smaller type
to a larger type.  'Smaller' and 'larger' in this case refers to the amount of
bytes the type occupies in memory.  'Promotion' is gauranteed to produce the
exact same value in the destination type.


Other conversions between arithmetic types may not always be able to represent
the same value exactly:

    - If a negative integer value is converted to an unsigned type, the
      resulting value corresponds to its 2's complement bitwise representation.
      -1 becomes the largest value representable by the type, -2 the second
      largest, ....
    - conversions from/to bool consider 'false' equivalent to zero (for numeric
      types) and to nullptr (for pointer types).  'true' is equivalent to all
      other values and is converted to the equivalent of 1
    - floating-point to an integer type:
        the value is truncated (the decimal part is removed).  If the result
        lies outside the range of representable values by the type, the
        conversion causes UNDEFINED BEHAVIOR
    - If the conversion is between numeric types of the same kind, the
      conversion is valid, but the value is IMPLEMENTATION SPECIFIC and may not
      be portable.

Some of these conversions may imply a loss of precision, which the compiler can
signal with a warning.  The warning can be avoided with an EXPLICIT CONVERSION.

For non-fundamental types, arrays, and function can be implicitly converted to
pointers and pointers in general allow the following conversions:

    - Null pointers can be converted to pointers of any type
    - Pointers to any type can be converted to void pointers
    - Pointer upcast: pointers to a derived class can be converted to a pointer
      of an accessible and unambiguous base class, without modifying its const
      or volatile qualification.


IMPLICIT CONVERSIONS WITH CLASSES
-------------------------------------------------------------------------------
In the world of classes, implicit conversoins can be controlled by a means of
three member functions.  They are:

    SINGLE ARGUMENT CONSTRUCTORS:
        allows implicit conversion from a particular type to initialize an
        object

    ASSIGNMENT OPERATOR:
        allows implicit conversion from a particular type on assignments

    TYPECAST OPERATOR:
        allows implicit conversion to a particular type

EXPLICIT KEYWORD
-------------------------------------------------------------------------------
On a function call, cpp allows one implicit conversion to happen for each
argument.  For classes this may be problematic because it is not always what is
intended.  The explicit keyword can prevent this implicit conversion.  The
syntax is shown in the example below.


EXAMPLE DEMONSTRATING IMPLICIT CONVERSIONS AND THE EXPLICIT KEYWORD:

    class A {};

    class B {
      public:
        // conversion from A (constructor)
        // without the explicit keyword, we could pass
        // a B object in this constructor and it would
        // run fine
        explicit B(const A &a) {
        }

        // conversion from A (assignment)
        B &operator=(const A &a) {
            return *this;
        }

        // conversion to A (typecast operator)
        // return type is the destination type
        operator A() {
            return A();
        }
    };

    int main() {
        A foo;

        // while this is a single argument constructor, constructors marked with
        // explicit cannot be called with the assignment-like syntax like this:
        // B bar = foo
        B bar (foo);

        // calls assignment
        bar = foo;

        // calls typecast operator
        foo = bar;

        return 0;
    }


TYPE CASTING
-------------------------------------------------------------------------------
Cpp is a strongly typed language.  Many conversions, especially those which
imply a different interpretation of the value, require an explicit conversion,
which is known as type-casting in cpp.  Converting an int to a double is an
example of promotion because double takes up more bytes and can therefore be
implicitly converted.  However, the opposite requires type-casting.


GENERIC TYPE CASTING
-------------------------------------------------------------------------------
There are two main syntaxes for generic type-casting.  They are FUNCTIONAL and
C-LIKE.

    double x = 10.3;
    int y;

    y = int(x);  // functional notation
    y = (int) x; // c-like notation

The functionality of these generic forms of type-casting is enough for most
needs with fundamental data types.  However, these operators can be applied
indiscriminately on classes and pointers to classes.  While the code may be
syntactically correct, these generic forms of type-casting can cause runtime
errors.

    class Dummy {
        double x, y;
    };

    class Addition {
        int x, y;

      public:
        Addition(int x, int y) :
            x(x),
            y(y) {
        }

        int result() {
            return x + y;
        }
    };

    int main() {
        Dummy d;
        Addition *pAdd;

        // c-like notation (generic type casting)
        pAdd = (Addition *)&d;

        // no error is thrown, but this leads to undefined behavior
        std::cout << pAdd->result() << '\n';

        return 0;
    }

In order to control these types of conversions between classes, there are four
specific casting operators:

    dynamic_cast
    reinterpret_cast
    static_cast
    const_cast

The syntax of these is as follows:

    dynamic_cast<newType>(expression)

    reinterpret_cast<newType>(expression)

    static_cast<newType>(expression)

    const_cast<newType>(expression)

UPCAST VS DOWNCAST:

    POINTER UPCAST:
    converting from POINTER TO DERIVED to POINTER TO BASE

    POINTER DOWNCAST
    converting from POINTER TO BASE to POINTER TO DERIVED


DYNAMIC_CAST
-------------------------------------------------------------------------------
dynamic_cast can only be used with pointers and references to classes (or with
void *).  Its purpose is to ensure that the result of the type conversion points
to a valid complete object of the destination pointer type.

IMPORTANT: dynamic_class cannot be successfully used as pointer upcast.

When dynamic_cast cannot cast a pointer because it is not a complete object of
the required class, it returns a null pointer to indicate the failure.

If dynamic_cast is used to convert a reference type and the conversion is not
possible, an exception of type bad_cast is thrown instead.

dynamic_cast can also cast any pointer of any type to a 'void *' pointer.

Example:

    class Base {
        virtual void dummy(){};
    };

    class Derived : public Base {
        int x;
    };

    int main() {
        try {
            Base *pBase1 = new Derived;
            Base *pBase2 = new Base;
            Derived *pDer;

            pDer = dynamic_cast<Derived *>(pBase1);
            if (pDer == nullptr) {
                std::cout << "Null pointer on first type-cast.\n";
            }

            pDer = dynamic_cast<Derived *>(pBase2);
            if (pDer == nullptr) {
                // this is printed out
                std::cout << "Null pointer on second type-cast.\n";
            }
        } catch (std::exception &e) {
            std::cout << "Exception: " << e.what();
        }

        return 0;
    }

The reason only the second dynamic_cast is a null pointer is because Base is an
incomplete object of the Derived class.


STATIC_CAST
-------------------------------------------------------------------------------
static_cast can perform conversions between to related classes.

static_cast can perform both UPCASTS AND DOWNCASTS

No checks are performed during runtime to gaurantee that the object being
converted is in fact a full object of the destination type.  Therefore, is it up
to the programmer to ensure that the conversion is safe.  While this may be less
safe, it does not incur the overhead of the type-safety checks of a
dynamic_cast.  (with great power comes great responsibility!)

    class Base {};
    class Derived : public Base {};

    Base *pBase = new Base;
    Derived *pDer = static_cast<Derived *>(pBase);

static_cast can also perform the following:
    - convert from void * to any poiner type
    - explicitly call a single-argument constructor or a conversion operator
    - convert to rvalue references (&&)
    - convert enum class values into integers or floating-point values
    - convert type to void, evaluating and discarding the value


REINTERPRET_CAST
-------------------------------------------------------------------------------
reinterpret_cast converts any pointer type to any other pointer type, even of
unrelated classes.

The operation is a simple binary copy of the vlaue from one pointer to the
other.

All pointer conversions are allowed.  Neither the content pointed nor the
pointer type itself is checked.

It can also cast pointers to or from integer types.

Because reinterpret_cast conversions are based on low-level operations
reinterpreting the binary representations of the types, which is system
specific, conversions performed by reinterpret_cast are non-portable.

    class A { /* ... */ };
    class B { /* ... */ };
    A *a = new A;
    B *b = reinterpret_cast<B *>(a);

The above example compiles, although it might not make much sense because b now
points to an object which is totally unrelated to its pointer type and therefore
most likely entirely incompatible.  Dereferencing b is unsafe.


CONST_CAST
-------------------------------------------------------------------------------
const_cast manipulates the constness of the object pointed by a pointer, either
to be set or to be removed

Example of passing a const pointer to a function that expects a non-const
argument.

    void print(char *s) {
        std::cout << s << '\n';
    }

    int main() {
        const char *c = "sample text";
        // remove the const qualifer from c
        print(const_cast<char *>(c));

        return 0;
    }

You cannot pass a const const pointer to a function that expect a non-const
argument, so in the example above the const_cast was necessary to pass an rvalue
of the 'c' pointer without the const qualifier.

This example works because the print function does not actually modify anything,
however, if it were to modify s, it would cause undefined behavior because you
would be still be modifying a value which was marked as read only in the
assignment of "sample" text to 'const char *c'


TYPEID
-------------------------------------------------------------------------------
typeid is an operator that allows you to check the type of an expression

    typeid(expression)

The typeid operator returns a reference to a constant object of type type_info
that is defined in the standard header <typeinfo>

A value returned by tpeid can be compared with another value returned by typeid
in a conditional, or it can serve to obtain a null-terminated character sequence
representing the data type or class name by using its name() member.

    #include <iostream>
    #include <typeinfo>

    int main() {

        int *x, y;
        x = 0; // x is of type: 'int *'
        y = 0; // y is not a pointer, it is of type: 'int'

        if (typeid(x) != typeid(y)) {
            std::cout << "x and y are of different types\n";
            std::cout << "x is: " << typeid(x).name() << '\n';
            std::cout << "y is: " << typeid(y).name() << '\n';
        }

        return 0;
    }

The string returned by member function 'name' of 'type_info' depends on the
specific implementation of the compiler and library.  The format may not always
be a simple string with its typical type name.


-------------------------------------------------------------------------------
EXCEPTIONS
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/exceptions/
-------------------------------------------------------------------------------
Exceptions provide a way to react to 'exceptional circumstances' (like runtime
errors) in programs by transferring control to special functions called
HANDLERS.

To catch exceptions, a portion of code is placed under exception inspection.
This is doe by enclosing that portion of code in a TRY BLOCK.  When an
exceptional circumstance arises within that block, an exception is thrown that
transfer the control the exception handler.

If no exception is thrown, the code continues normally and all handlers are
ignored.

In the example below, an exception is thrown by using the THROW keyword from
inside the TRY block.  The exception handler is declared with the keyword CATCH
which comes immediately after the TRY block.

    try {
        throw 50;
    } catch (int e) {
        std::cout << "An exception has occured brah.  Exception Number " << e
                  << '\n';
    }


THROW KEYWORD
-------------------------------------------------------------------------------
A throw expression accepts one parameter which is passed as an argument to the
exception handler.  If no argument is given, the you will need to use an
'ellipsis' as a parameter for the catch handler which catches all exceptions no
matter the 'type' thrown by the throw expression.

    try {
        throw;
    } catch (...) {
        std::cout << "Default exception has occurred\n";
    }


CATCH KEYWORD
-------------------------------------------------------------------------------
The catch keyword is declared immediately after the closing brace of the try
block.  The syntax is similar to that of a regular function with one parameter.

It is important that the catch parameter be of the same type as the argument
passed by the throw expression.  In the above example we knew the argument would
be of type 'int' because we explicitly threw that exception ourselves.  However,
in more practical situations it will not always be so obvious.  There are a
couple different ways of ahndling this.

1.  CHAINING HANDLERS (CATCH EXPRESSIONS)

    try {
        throw 50;
    } catch (char e) {
        std::cout << "Char exception: " << e << '\n';
    } catch (int e) {
        std::cout << "Int exception: " << e << '\n';
    }

In this example, only "Int exception: 50" will be printed out.

2. USING AN ELLIPSIS (...) AS AN PARAMETER OF THE CATCH HANDLER

    try {
        throw "Brah";
    } catch (char e) {
        std::cout << "Char exception: " << e << '\n';
    } catch (int e) {
        std::cout << "Int exception: " << e << '\n';
    } catch (...) {
        std::cout << "Default exception has occurred\n";
    }

Only "Default exception has occurred" will be printed out.  Notice that using an
ellipsis as a parameter of the catch handler does not accept an an additional
parameter?  We cannot print the value thrown by the throw expression in this
way.


NESTING TRY CATCH BLOCKS
-------------------------------------------------------------------------------
It is possible to nest try-catch blocks within external try blocks.In this case,
the internal catch block forwards the exception to its external level.

    try {
        try {
            throw 50;
        } catch (int e) {
            throw 100;
        }
    } catch (int e) {
        std::cout << "Exception: '" << e << "' has occurred\n";
    }

The above example prints: "Exception: '100' has occurred"


EXCEPTION SPECIFICATION
-------------------------------------------------------------------------------
Older code may contain DYNAMIC EXCEPTION SPECIFICATIONS.  These are now
deprecated in cpp, but still supported.  A DYNAMIC EXCEPTION SPECIFICATION
follows the declaration of a function appending a throw specifier to it.

    double myFunction (char param) throw (int);

If the myFunction function throws an exception of some type OTHER THAN int, the
function calls std::unexpected, or calls std::terminate.

If the throw paramer is left empty with no type, std::unexpected is claled for
any exception.

Functions with no throw specifer (regular functions) never call std::unexpected,
but follow the normal path of looking for their exception handler.


STANDARD EXCEPTIONS
-------------------------------------------------------------------------------
The std library provides a base class specifically designed to declare objects
thrown as exceptions.  It is called std::exception and is defined in the
<exception> header.  This class has a virtual member function called 'what' that
returns a null-terminated character sequence of type char pointer (char *), and
that can be overwritten in derived classes to contain a custom description of
the exception.

    #include <exception>
    #include <iostream>

    class MyException : public std::exception {
        virtual const char *what() const throw() {
            return "My exception occurred\n";
        }
    } myException;

    int main() {
        try {
            throw myException;
        } catch (std::exception &e) {
            std::cout << e.what() << '\n';
        }

        return 0;
    }

All exceptions why are thrown by components of the cpp std library are throw
exceptions which are derived from the std::exception class.  These are:

    EXCEPTION         | DESCRIPTION
    ------------------|--------------------------------------------------------
    bad_alloc         | thrown by 'new' on allocation failure
    ------------------|--------------------------------------------------------
    bad_cast          | thrown by 'dynamic_cast' when it fails in a dynamic cast
    ------------------|--------------------------------------------------------
    bad_exception     | thrown by certain dynamic exception specifiers
    ------------------|--------------------------------------------------------
    bad_typeid        | thrown by typeid
    ------------------|--------------------------------------------------------
    bad_function_call | thrown by empty function objects
    ------------------|--------------------------------------------------------
    bad_weak_ptr      | thrown by 'shared_ptr' when passed a bad 'weak_ptr'
    ------------------|--------------------------------------------------------

Also derived from exception, header <exception> defines two generic exception
types that can be inherited by custom exceptions to report errors:

    logic_error
        error related to the internal logic of the program

    runtime_error
        error detected during runtime


Example of using memory allocation to check if a standard exception is thrown.
The exception handler in this example would be bad_alloc.

    try {
        int *myArray = new int[1000];
    } catch (std::exception &e) {
        std::cout << "Standard exception: " << e.what() << '\n';
    }


-------------------------------------------------------------------------------
PREPROCESSOR DIRECTIVES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/preprocessor/
-------------------------------------------------------------------------------
Preprocessor directives are lines included in the code of programs preceded by a
hash sign (#).  These lines are not statements, but directives for the
preprocessor.

The preprocessor is what examines the code for actual compilation of the code
begins and RESOLVES all these directives before any code is actually generated
by regular statements.

Preprocessor directives extend across only a single line of code.  They are not
to be ended with a semicolon (;) like normal cpp statements.  Instead, as soon
as a newline character is found, the preprocessor directive is ended.  A
preprocessor directive CAN extend through more than one line by escaping the
newline character at the end of a line with a backslash.


MACRO DEFINITIONS ( #define, #undef )
-------------------------------------------------------------------------------

#DEFINE
-------------------------------------------------------------------------------

    #define identifier replacement

When the preprocessor encounters the #define directive, it replaces every
occurence of 'identifier' in the rest of the code by 'replacement'.  This
'replacement' can be an expression, statement, a block, or simply anything.  The
cpp preprocessor does not understand cpp code.  It simply replaces any occurance
of identifier by replacement.

    #define TABLE_SIZE 100
    int table1[TABLE_SIZE];
    int table2[TABLE_SIZE];

After the preprocessor has replaced TABLE_SIZE, the code becomes equivalent to:

    int table1[100];
    int table2[100];

#define can also work with parameters to define function macros.  It replaces
not only every occurrence of the function name, but also replaces each
argument's identifier.

    #define getMax(a, b) (a > b ? a : b)

    int main() {
        int y = getMax(5, 6);
        std::cout << y << '\n';
        std::cout << getMax(10, 3) << '\n';
    }

Defined macros are not affected by scope / block structure.  A macro lasts until
it is undefined with the #undef preprocessor directive.


#UNDEF
-------------------------------------------------------------------------------
'undefines' a 'defined' macro

This block of code:

    #define TABLE_SIZE 100
    int table1[TABLE_SIZE];

    #undef TABLE_SIZE
    #define TABLE_SIZE 200
    int table2[TABLE_SIZE]

is the same as:

    int table1[100];
    int table2[200];


FUNCTION MACROS
-------------------------------------------------------------------------------
Function macro definitions accept two special operators (# and ##) in the
replacement sequence.

(#)
    # followed by a parameter name is replaced by a Some literal that contains
    the argument passed.  The identifier which follows the # must be a parameter
    identifier.

    #define testFn(x) #x
    std::cout << testFn(test) << '\n';
    // is the same as
    std::cout << "test" << '\n';

    This might be useful for very simple utility functions.

(##)
    ## concatenates two arguments, leaving no blank space between them

    #include <iostream>
    #include <string>

    #define glue(a, b) a##b

    int main() {

        std::string brodude = "brodude";
        std::cout << glue(bro, dude) << '\n';

        return 0;
    }

    This would not worked if the identifier 'brodude' was not already defined.
    Unlike with #, ## does not turn the arguments into string literals, it
    merely concatenates the arguments together without quotation marks.


CONDITIONAL INCLUSIONS ( #IFDEF, #IFNDEF, #IF, #ENDIF, #ELSE, AND ELIF )
-------------------------------------------------------------------------------
Conditional inclusions are directives which allow to include or discard part of
the code of a program if a certain condition is met.


#IFDEF / #ENDIF
-------------------------------------------------------------------------------
The code between #ifdef and #endif is compiled ONLY under the circumstances
that all macros within have been defined with the #define directive.

    #define I 100
    #ifdef I
    int i = I;
    #endif

    int main() {
        std::cout << i << '\n';

        return 0;
    }

The above runs with no errors, but if the #define directive were removed, then
trying to access the value of 'i' in the std::cout statement would throw an
error because the compiler would not have compiled its initialization.


#IFNDEF / #ENDIF
-------------------------------------------------------------------------------
#ifndef is the opposite of #ifdef.  The lines between #ifndef and #endif will
only be compiled if the specified identifier has not yet been previously
defined.

    #define I 100

    // if I is not defined
    #ifndef I
    int i = I;
    #endif

    int main() {
        std::cout << i << '\n';

        return 0;
    }

In the example above, the std::cout statement will throw an error because the 'I'
identifier was already defined with the #define preprocessor directive.
Therefore, since I was already defined, the 'i' variable will never be compiled
since it uses the 'I' identifier to initialize its value.

The more practical way of using #ifndef would be to something more like this:

    // #define I 100

    // if I is not defined (it isn't because we commented it out)
    #ifndef I
    #define I 200
    #endif
    int i = I;

    int main() {
        std::cout << i << '\n';

        return 0;
    }

The std::cout statement prints 200, because the code between #ifndef uses
#define to define I as 200


#IF, #ELSE, #ELIF
-------------------------------------------------------------------------------
These directives serve to specify that some condition needs to be met in order
for the position of code they sound surround to be compiled.  The condition that
#if or #elif can only evaluate to a constant expression, including macro
expressions

    #ifndef TABLE_SIZE
    #define TABLE_SIZE 75
    #endif

    #if TABLE_SIZE > 200
    #undef TABLE_SIZE
    #define TABLE_SIZE 50

    #elif TABLE_SIZE < 50
    #undef TABLE_SIZE
    #define TABLE_SIZE 50

    #else
    #undef TABLE_SIZE
    #define TABLE_SIZE 100
    #endif

    int main() {

        std::cout << TABLE_SIZE << '\n'; // 100

        return 0;
    }

The behavior of above can be replicated by using the the special operators
'defined' and '!defined', which is makes the code more closely aligned with the
#ifdef adn #ifndef directives.


    #if !defined(TABLE_SIZE)
    #define TABLE_SIZE 75
    #endif

    #if defined(TABLE_SIZE)
       #if TABLE_SIZE > 200
       #undef TABLE_SIZE
       #define TABLE_SIZE

       #elif TABLE_SIZE < 50
       #undef TABLE_SIZE
       #define TABLE_SIZE 50

       #else
       #undef TABLE_SIZE
       #define TABLE_SIZE 100
       #endif
    #endif

    int main() {

        std::cout << TABLE_SIZE << '\n'; // 100

        return 0;
    }


#LINE ( LINE CONTROL )
-------------------------------------------------------------------------------
When a program is compiled and some error happens during the compiling process,
the compilershows an error message with references to the file where the error
happended and a line number, which makes it easier to find the code generating
the error.

The #line directive allows us to control botht eh line numbers within the code
files as well as the file name that we want to appear when an error takes palce:

    #line number "filename"

'number' is the new line number that will be assigned to the next code line.
The line numbers of successive lines will be increases one by one from this
point on.

"filename" is an optional parameter but allows to redefine the file name that
will be shown


    #line 20 "assigning variable"
    int a?;

This code will generate an error that will be shown as:

    "assigning variable", line 20


#ERROR ( ERROR DIRECTIVE )
-------------------------------------------------------------------------------
The #error directive aborts the compilation process when it is found,
generating a compilation error that can be specified as its parameter.

    #ifndef __cplusplus
    #error A C++ compiler is required
    #endif

The example aborts the compilation process if the macro name __cplusplus is not
defined.

NOTE: The macro name __cplusplus is defined by default in all cpp compilers.


#INCLUDE ( SOURCE FILE INCLUSION )
-------------------------------------------------------------------------------
When the preprocessor finds an #include directive, it replaces it by the entire
content of the specified header or file.  There are two ways to use include:

    #include <header>
    #include "file"

In the first case, a 'header' is specified between angle brackets <>.  This is
used to include headers provided by the implementation, such as headers that
compose the standard library (iostream, string, ...).  Whether the headers are
actually files or in some other form is IMPLEMENTATION DEFINED, but in any case
they shall be properly included with the #include directive.

IMPLEMENTATION DEFINED refers to behavior which is left open for compilers or
runtime environments to define.

In the second case, a file is searched for in and IMPLEMENTATION DEFINED manner,
which generally includes the current path.  In the case that the file is not
found, the compiler interprets the direction as a 'header' inclusion, just as
if you wrote it without angle brackets instead

    #include "file.h"
    // if the compiler couldn't find file.h, it would be the same as the
    // following line uncommented out
    // #include <file.h>


MORE ON FILE INCLUSION ( .h / .hpp files)
-------------------------------------------------------------------------------
Header files (.h or .hpp) typically contain declarations, while source files
(.cpp) contain definitions.


#PRAGMA ( PRAGMA DIRECTIVE )
-------------------------------------------------------------------------------
The #pragma directive is used to specify diverse options to the compiler.  These
options are specific to the platform and compiler being used, so to use the
#pragma directive, the documentation for your specific compiler will give more
information on possible parameters that can be defined with the #pragma
directive.

If thecompiler does not support a specific argument for #pragma, it is ignored
and no syntax error is generated.


PREDEFINED MACRO NAMES
-------------------------------------------------------------------------------

    std::cout << "TIME of compilation: " << __TIME__ << '\n';
    std::cout << "DATE of compilation: " << __DATE__ << '\n';
    std::cout << "FILE of source file being compiled: " << __FILE__ << '\n';
    std::cout << "LINE # of this statement: " << __LINE__ << '\n';
    std::cout << "Integer constant reffering to a given compiler: "
              << __cplusplus << '\n';

There are also some macros which are optionally predefined, generally depending
on whether or not a feature is available.

    __STD__
    __STDC_VERSION
    __STDC_MB_MIGHT_NEQ_WC__
    __STDC_ISO_10646__
    __STDCPP_STRICT_POINTER_SAFETY
    __STDCPP_THREADS__


-------------------------------------------------------------------------------
INPUT / OUTPUT WITH FILES
-------------------------------------------------------------------------------
https://cplusplus.com/doc/tutorial/files/
-------------------------------------------------------------------------------
The following section is not very well documented and it would be better to use
this as a general idea of where to start when needing to work with files.

Cpp provides the following classes in the standard library to perform output and
input of characters to/from files:

    ofstream
        stream class to write on files

    ifstream
        stream class to read from files

    fstream
        stream class to read AND write from/to files

All of these classes are derived directly or indirectly from the classes
<istream> and <ostream>.  In fact, cin and cout objects of the classes istream
and ostream respectively.  We can use our fstreams in a very similar way to how
cin and cout are used.


WRITING TO A FILE WITH FSTREAM
-------------------------------------------------------------------------------

    #include <fstream>

    int main() {
        std::ofstream myFile;
        myFile.open("example.txt");
        myFile << "Writing this to example.txt\n";
        myFile.close();

        return 0;
    }

Here is a step by step breakdown of the above example:

OPEN A FILE:
    The first operation generally performed by an object of one of these classes
    is to associate it to a file.  This procedure is known as to 'open a file'.
    An open file is represented within a program by a 'stream' which is an
    object of one of these classes, and any input or output operation performed
    on this stream object will be applied to the physical file associated to it.

    In the example above, the object was 'myFile', which was created, not
    opened.

    To open a file with a stream object, use its member function 'open':

        open(filename, mode);

    Where 'filename' is a string representing the name of the file to be opened,
    and 'mode' is an optional parameter with a combination of the following
    flags:

        ios::in (open for input ops)

        ios::out (open for output ops)

        ios::binary (open in binary mode)

        ios::ate (set the initial position at the end of the file)

        ios::app (all output ops are performed at the end of the file, appends
        content)

        ios::trunc (if the file is opened for output ops and it already existed,
        previous content is delted and replaced by the new one)

    All these flags can be combined using the bitwise operator OR |

        ofstream myFile;
        myFile.open("example.bin", ios::out | ios::app | ios::binary );

    Each of the open member functions of classes 'ofstream', 'ifstream', and
    'fstream' have a default mode that is used if the file is opened without a
    second arg:

        ofstream: ios::out
        ifstream: ios::in
        fstream: ios::in | ios::out

CLOSING A FILE:
    When we are finisherd with out input and output operations on a file, we
    shall close it so that the operating system is notified and its resources
    become available again.  For that we call the stream's member function
    'close'

        myFile.close();

    Once this member function is called, the stream object cna be re-used to
    open a separate file and the file is available again to be opened by other
    processes.

    In the case that an object is destroyed while still associated with an open
    file, the detructor automatically calls the member function close.


TEXT FILES
-------------------------------------------------------------------------------
Text file streams are those where the ios::binary flag is not included int ehir
opening mode.  These files are designed to store text and thus all values that
are input or output from/to them can suffer some formatting transformations,
which do not necessarily correspond to their literal binary value.

    #include <fstream>
    #include <iostream>

    int main() {
        std::ofstream myFile("example2.txt");
        if (myFile.is_open()) {
            myFile << "This is a line\n";
            myFile << "This is another line\n";
            myFile.close();
        } else {
            std::cout << "Unable to open file";
        }

        return 0;
    }

Example showing how to read from a file using std::ifstream:

    #include <fstream>
    #include <iostream>
    #include <string>

    int main() {
        std::ofstream createfile("example.txt");
        createfile << "brah\nbrah\nbrah\n";
        createfile.close();

        std::string line;
        std::ifstream myfile("example.txt");

        if (myfile.is_open()) {
            while (std::getline(myfile, line)) {
                std::cout << line << '\n';
            }
            myfile.close();
        } else {
            std::cout << "unable to open file\n";
        }

        return 0;
    }


CHECKING STATE FLAGS
-------------------------------------------------------------------------------
The following member functions exist to check for specific states of a stream.
They all return a value of type 'bool'.

bad()
    returns true if a reading or writing operation fails.  For example, if the
    file is not open for writing, or if the device where we try to write has no
    space left

fail()
    returns true in the same cases as bad(), but also in the case that a format
    error happens, such as when an alphabetical character is extracted while
    trying to read an integer number

eof()
    (end of file) returns true if a file open for reading has reached the end

good()
    The most generic state flag.  Returns false in the same cases in which any
    of the previous functions would return true.  Note: good() and bad() are not
    exact opposites (good checks more state flags at once)

The member function clear() can also be used to reset the state flags.


GET AND PUT STREAM POSITIONING
-------------------------------------------------------------------------------
All i/o streams keep internally AT LEAST one internal position

ifstream and istream keep an internal GET position with the location of the
element to be read in the next input operation

ofstream and ostream keep an internal PUT position with the location where the
next element has to be written

fstream keeps both the GET and PUT position, like iostream.

These internal stream positions point to the locations witht he stream where the
next reading or writing operation is performed.  These positions can be observed
and modified using the following member functions:

tellg() and tellp()
    These two member functions with no parameters return value of the member
    type 'streampos', which is a type representing the current GET or PUT
    position.  tellg() gets the current GET position, while tellp() gets the
    current PUT position

seekg() seekp()
    These functions allow to change the location of the get and put positions.
    Both functions are overloaded with two different prototypes.  The two
    different forms are:

        seekg(position);
        seekp(position);

    and

        seekg(offset, direction);
        seekp(offset, direction);

Example:

    std::streampos begin, end;
    std::ifstream myFile("example.bin", std::ios::binary);
    begin = myFile.tellg();
    myFile.seekg(0, std::ios::end);
    end = myFile.tellg();
    myFile.close();
    std::cout << "size is: " << (end - begin) << "bytes.\n";


BINARY FILES
-------------------------------------------------------------------------------
For binary files, reading and writing data with the extraction and insertion
operators ( << and >>) and functions like std::getline is not efficient, since
we do not need to format any data and data is likely not formatted in lines.

File streams include two member functions specifically designed to read and
write binary data sequentially: 'write' and 'read'. 'write' is a member function
of ostream (inherited by ofstream) and 'read' is a member function of istream
(inherited by ifstream).  Objects of class fstream have both.  The protoypes of
write and read are:

    write (memory_block, size)
    read (memory_block, size)

'memory_block' is of type 'char *' (pointer to char), and represents the address
of an arrray of bytes where the read data elements are stored, or from where the
data elements to be written are taken.  The 'size' parameter is an integer value
that specifies the number of chars to be read or written from/to the memory
block.

    #include <fstream>
    #include <iostream>

    int main() {
        std::streampos size;
        char *memBlock;

        std::ifstream file("example.bin",
                           std::ios::in | std::ios::binary | std::ios::ate);
        if (file.is_open()) {
            size = file.tellg();
            memBlock = new char[size];
            file.seekg(0, std::ios::beg);
            file.read(memBlock, size);
            file.close();

            std::cout << "The file content is in memory\n";

            delete[] memBlock;
        }

        return 0;
    }


BUFFERS AND SYNCHRONIZATION
-------------------------------------------------------------------------------
When operating with file streams, these are associated to an internal buffer
object of type 'streambuf'.  This buffer object may represent a memory block
that acts as an intermediary between the stream and the physical file.  For
example, with an ofstream, each time the member function 'put' (which writes
single character) is called, the character may be inserted in this intermediate
buffer instead of being written directly to the physical file with which the
stream is associated.

When the buffer is flushed, all the data contained in it is written to the
physical medium (if it is an output stream).  This process is called
synchronization and takes place under any of the following circumstances:

    When the file is closed
    When the buffer is full
    Explicitly, with manipulators
    Explicitly, with member function sync()


-------------------------------------------------------------------------------
THIS CONCLUDES THE END OF NOTES FROM CPLUSPLUS.COM TUTORIAL
-------------------------------------------------------------------------------
*** for future reference use:
    cppreference.com
    learncpp.com
-------------------------------------------------------------------------------










































































































































